

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Welcome to pyEMU’s documentation! &mdash; pyEMU 0.9 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pyemu.Pst" href="_autosummary/pyemu.Pst.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> pyEMU
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.Pst.html">pyemu.Pst</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.Matrix.html">pyemu.Matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.Cov.html">pyemu.Cov</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.Schur.html">pyemu.Schur</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.ErrVar.html">pyemu.ErrVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.ObservationEnsemble.html">pyemu.ObservationEnsemble</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.ParameterEnsemble.html">pyemu.ParameterEnsemble</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.helpers.html">pyemu.helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.geostats.html">pyemu.geostats</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.gw_utils.html">pyemu.gw_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.pp_utils.html">pyemu.pp_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.smp_utils.html">pyemu.smp_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.plot_utils.html">pyemu.plot_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="_autosummary/pyemu.pst_utils.html">pyemu.pst_utils</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">pyEMU</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#">Docs</a> &raquo;</li>
        
      <li>Welcome to pyEMU’s documentation!</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="welcome-to-pyemu-s-documentation">
<h1>Welcome to pyEMU’s documentation!<a class="headerlink" href="#welcome-to-pyemu-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="_autosummary/pyemu.Pst.html#pyemu.Pst" title="pyemu.Pst"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.Pst</span></code></a></p></td>
<td><p>All things PEST(++) control file</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="_autosummary/pyemu.Matrix.html#pyemu.Matrix" title="pyemu.Matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.Matrix</span></code></a></p></td>
<td><p>Easy linear algebra in the PEST(++) realm</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="_autosummary/pyemu.Cov.html#pyemu.Cov" title="pyemu.Cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.Cov</span></code></a></p></td>
<td><p>Diagonal and/or dense Covariance matrices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="_autosummary/pyemu.Schur.html#pyemu.Schur" title="pyemu.Schur"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.Schur</span></code></a></p></td>
<td><p>FOSM-based uncertainty and data-worth analysis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="_autosummary/pyemu.ErrVar.html#pyemu.ErrVar" title="pyemu.ErrVar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.ErrVar</span></code></a></p></td>
<td><p>FOSM-based error variance analysis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="_autosummary/pyemu.ObservationEnsemble.html#pyemu.ObservationEnsemble" title="pyemu.ObservationEnsemble"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.ObservationEnsemble</span></code></a></p></td>
<td><p>Observation noise ensemble in the PEST(++) realm</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="_autosummary/pyemu.ParameterEnsemble.html#pyemu.ParameterEnsemble" title="pyemu.ParameterEnsemble"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.ParameterEnsemble</span></code></a></p></td>
<td><p>Parameter ensembles in the PEST(++) realm</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="_autosummary/pyemu.helpers.html#module-pyemu.helpers" title="pyemu.helpers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.helpers</span></code></a></p></td>
<td><p>High-level functions to help perform complex tasks</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="_autosummary/pyemu.geostats.html#module-pyemu.geostats" title="pyemu.geostats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.geostats</span></code></a></p></td>
<td><p>Geostatistics in the PEST(++) realm</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="_autosummary/pyemu.gw_utils.html#module-pyemu.gw_utils" title="pyemu.gw_utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.gw_utils</span></code></a></p></td>
<td><p>MODFLOW support utilities</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="_autosummary/pyemu.pp_utils.html#module-pyemu.pp_utils" title="pyemu.pp_utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.pp_utils</span></code></a></p></td>
<td><p>Pilot point support utilities</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="_autosummary/pyemu.smp_utils.html#module-pyemu.smp_utils" title="pyemu.smp_utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.smp_utils</span></code></a></p></td>
<td><p>PEST-style site sample (smp) file support utilities</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="_autosummary/pyemu.plot_utils.html#module-pyemu.plot_utils" title="pyemu.plot_utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.plot_utils</span></code></a></p></td>
<td><p>Plotting functions for various PEST(++) and pyemu operations</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="_autosummary/pyemu.pst_utils.html#module-pyemu.pst_utils" title="pyemu.pst_utils"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyemu.pst_utils</span></code></a></p></td>
<td><p>Various PEST(++) control file peripheral operations</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
<span class="target" id="module-pyemu.pst"></span><p>This is the pyemu module for handling PEST control files. It provides functionality
for reading and writing control files, creating new control files, and manipulating
all sections of the control file.  The primary object is the Pst…start there.</p>
<dl class="class">
<dt id="pyemu.pst.Pst">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.pst.</code><code class="sig-name descname">Pst</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">load=True</em>, <em class="sig-param">resfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst" title="Permalink to this definition">¶</a></dt>
<dd><p>All things PEST(++) control file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – the name of the control file</p></li>
<li><p><strong>load</strong> (<cite>bool</cite>, optional) – flag to load the control file. Default is True</p></li>
<li><p><strong>resfile</strong> (<cite>str</cite>, optional) – corresponding residual file.  If <cite>None</cite>, a residual file
with the control file base name is sought.  Default is <cite>None</cite></p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is the primary mechanism for dealing with PEST control files.  Support is provided
for constructing new control files as well as manipulating existing control files.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">control_data</span><span class="o">.</span><span class="n">noptmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;my_new.pst&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.pst.Pst.add_observations">
<code class="sig-name descname">add_observations</code><span class="sig-paren">(</span><em class="sig-param">ins_file</em>, <em class="sig-param">out_file=None</em>, <em class="sig-param">pst_path=None</em>, <em class="sig-param">inschek=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.add_observations" title="Permalink to this definition">¶</a></dt>
<dd><p>add new observations to a control file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ins_file</strong> (<cite>str</cite>) – instruction file with exclusively new observation names</p></li>
<li><p><strong>out_file</strong> (<cite>str</cite>) – model output file.  If None, then ins_file.replace(“.ins”,””) is used.
Default is None</p></li>
<li><p><strong>pst_path</strong> (<cite>str</cite>) – the path to append to the instruction file and out file in the control file.  If
not None, then any existing path in front of the template or in file is split off
and pst_path is prepended.  If python is being run in a directory other than where the control
file will reside, it is useful to pass <cite>pst_path</cite> as <cite>.</cite>. Default is None</p></li>
<li><p><strong>inschek</strong> (<cite>bool</cite>) – flag to try to process the existing output file using the <cite>pyemu.InstructionFile</cite>
class.  If successful, processed outputs are used as obsvals</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the data for the new observations that were added</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>populates the new observation information with default values</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span><span class="s2">&quot;my.pst&quot;</span><span class="p">))</span>
<span class="n">pst</span><span class="o">.</span><span class="n">add_observations</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span><span class="s2">&quot;new_obs.dat.tpl&quot;</span><span class="p">,</span><span class="n">pst_path</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span><span class="s2">&quot;my_new.pst&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.add_parameters">
<code class="sig-name descname">add_parameters</code><span class="sig-paren">(</span><em class="sig-param">template_file</em>, <em class="sig-param">in_file=None</em>, <em class="sig-param">pst_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.add_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>add new parameters to an existing control file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>template_file</strong> (<cite>str</cite>) – template file with (possibly) some new parameters</p></li>
<li><p><strong>in_file</strong> (<cite>str</cite>) – model input file. If None, template_file.replace(‘.tpl’,’’) is used.
Default is None.</p></li>
<li><p><strong>pst_path</strong> (<cite>str</cite>) – the path to append to the template_file and in_file in the control file.  If
not None, then any existing path in front of the template or in file is split off
and pst_path is prepended.  If python is being run in a directory other than where the control
file will reside, it is useful to pass <cite>pst_path</cite> as <cite>.</cite>.  Default is None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the data for the new parameters that were added.
If no new parameters are in the new template file, returns None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>populates the new parameter information with default values</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span><span class="s2">&quot;my.pst&quot;</span><span class="p">))</span>
<span class="n">pst</span><span class="o">.</span><span class="n">add_parameters</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span><span class="s2">&quot;new_pars.dat.tpl&quot;</span><span class="p">,</span><span class="n">pst_path</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span><span class="s2">&quot;my_new.pst&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.add_pi_equation">
<code class="sig-name descname">add_pi_equation</code><span class="sig-paren">(</span><em class="sig-param">par_names</em>, <em class="sig-param">pilbl=None</em>, <em class="sig-param">rhs=0.0</em>, <em class="sig-param">weight=1.0</em>, <em class="sig-param">obs_group='pi_obgnme'</em>, <em class="sig-param">coef_dict={}</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.add_pi_equation" title="Permalink to this definition">¶</a></dt>
<dd><p>a helper to construct a new prior information equation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>par_names</strong> ([<cite>str</cite>]) – parameter names in the equation</p></li>
<li><p><strong>pilbl</strong> (<cite>str</cite>) – name to assign the prior information equation.  If None,
a generic equation name is formed. Default is None</p></li>
<li><p><strong>rhs</strong> (<cite>float</cite>) – the right-hand side of the pi equation</p></li>
<li><p><strong>weight</strong> (<cite>float</cite>) – the weight of the equation</p></li>
<li><p><strong>obs_group</strong> (<cite>str</cite>) – the observation group for the equation. Default is ‘pi_obgnme’</p></li>
<li><p><strong>coef_dict</strong> (<cite>dict</cite>) – a dictionary of parameter name, coefficient pairs to assign
leading coefficients for one or more parameters in the equation.
If a parameter is not listed, 1.0 is used for its coefficients.
Default is {}</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.add_transform_columns">
<code class="sig-name descname">add_transform_columns</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.add_transform_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>add transformed values to the <cite>Pst.parameter_data</cite> attribute</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>adds <cite>parval1_trans</cite>, <cite>parlbnd_trans</cite> and <cite>parubnd_trans</cite> to
<cite>Pst.parameter_data</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.adj_par_groups">
<em class="property">property </em><code class="sig-name descname">adj_par_groups</code><a class="headerlink" href="#pyemu.pst.Pst.adj_par_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parameter groups with atleast one adjustable parameter</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of parameter groups with
at least one adjustable parameter</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.adj_par_names">
<em class="property">property </em><code class="sig-name descname">adj_par_names</code><a class="headerlink" href="#pyemu.pst.Pst.adj_par_names" title="Permalink to this definition">¶</a></dt>
<dd><p>get the adjustable (not fixed or tied) parameter names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of adjustable (not fixed or tied)
parameter names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.adjust_weights">
<code class="sig-name descname">adjust_weights</code><span class="sig-paren">(</span><em class="sig-param">obs_dict=None</em>, <em class="sig-param">obsgrp_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.adjust_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the weights of observations or observation groups to contribute a specified
amount to the composite objective function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obs_dict</strong> (<cite>dict</cite>, optional) – dictionary of observation name,new contribution pairs</p></li>
<li><p><strong>obsgrp_dict</strong> (<cite>dict</cite>, optional) – dictionary of obs group name,contribution pairs</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if all observations in a named obs group have zero weight, they will all be
assigned a non-zero weight so that the request phi contribution
can be met.  Similarly, any observations listed in obs_dict with zero
weight will also be reset. User beware!</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>

<span class="c1"># adjust a single observation</span>
<span class="n">pst</span><span class="o">.</span><span class="n">adjust_weights</span><span class="p">(</span><span class="n">obs_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;obs1&quot;</span><span class="p">:</span><span class="mi">10</span><span class="p">})</span>

<span class="c1"># adjust a single observation group</span>
<span class="n">pst</span><span class="o">.</span><span class="n">adjust_weights</span><span class="p">(</span><span class="n">obsgrp_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;group1&quot;</span><span class="p">:</span><span class="mf">100.0</span><span class="p">})</span>

<span class="c1"># make all non-zero weighted groups have a contribution of 100.0</span>
<span class="n">balanced_groups</span> <span class="o">=</span> <span class="p">{</span><span class="n">grp</span><span class="p">:</span><span class="mi">100</span> <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">pst</span><span class="o">.</span><span class="n">nnz_obs_groups</span><span class="p">}</span>
<span class="n">pst</span><span class="o">.</span><span class="n">adjust_weights</span><span class="p">(</span><span class="n">obsgrp_dict</span><span class="o">=</span><span class="n">balanced_groups</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.adjust_weights_discrepancy">
<code class="sig-name descname">adjust_weights_discrepancy</code><span class="sig-paren">(</span><em class="sig-param">resfile=None</em>, <em class="sig-param">original_ceiling=True</em>, <em class="sig-param">bygroups=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.adjust_weights_discrepancy" title="Permalink to this definition">¶</a></dt>
<dd><p>adjusts the weights of each non-zero weight observation based
on the residual in the pest residual file so each observations contribution
to phi is 1.0 (e.g. Mozorov’s discrepancy principal)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>resfile</strong> (<cite>str</cite>) – residual file name.  If None, try to use a residual file
with the Pst case name.  Default is None</p></li>
<li><p><strong>original_ceiling</strong> (<cite>bool</cite>) – flag to keep weights from increasing - this is
generally a good idea. Default is True</p></li>
<li><p><strong>bygroups</strong> (<cite>bool</cite>) – flag to adjust weights by groups. If False, the weight
of each non-zero weighted observation is adjusted individually. If True,
intergroup weighting is preserved (the contribution to each group is used)
but this may result in some strangeness if some observations in a group have
a really low phi already.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pst</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span> <span class="c1">#assumes &quot;my.res&quot; is colocated with &quot;my.pst&quot;</span>
<span class="n">pst</span><span class="o">.</span><span class="n">adjust_weights_discrepancy</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pst</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span> <span class="c1"># phi should equal number of non-zero observations</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.build_increments">
<code class="sig-name descname">build_increments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.build_increments" title="Permalink to this definition">¶</a></dt>
<dd><p>experimental method to calculate parameter increments for use
in the finite difference pertubation calculations</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>user beware!</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.calculate_pertubations">
<code class="sig-name descname">calculate_pertubations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.calculate_pertubations" title="Permalink to this definition">¶</a></dt>
<dd><p>experimental method to calculate finite difference parameter
pertubations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The pertubation values are added to the
<cite>Pst.parameter_data</cite> attribute - user beware!</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.pst.Pst.control_data">
<code class="sig-name descname">control_data</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.pst.Pst.control_data" title="Permalink to this definition">¶</a></dt>
<dd><p>‘* control data’ information.
Access with standard PEST variable names</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span><span class="o">.</span><span class="n">control_data</span><span class="o">.</span><span class="n">noptmax</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pst</span><span class="o">.</span><span class="n">control_data</span><span class="o">.</span><span class="n">pestmode</span> <span class="o">=</span> <span class="s2">&quot;estimation&quot;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pyemu.pst.pst_controldata.ControlData</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.enforce_bounds">
<code class="sig-name descname">enforce_bounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.enforce_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>enforce bounds violation</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>cheap enforcement of simply bringing violators back in bounds</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.estimation">
<em class="property">property </em><code class="sig-name descname">estimation</code><a class="headerlink" href="#pyemu.pst.Pst.estimation" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the control_data.pestmode is set to estimation</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if <cite>control_data.pestmode</cite> is estmation, False otherwise</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.forecast_names">
<em class="property">property </em><code class="sig-name descname">forecast_names</code><a class="headerlink" href="#pyemu.pst.Pst.forecast_names" title="Permalink to this definition">¶</a></dt>
<dd><p>get the forecast names from the pestpp options (if any).
Returns None if no forecasts are named</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of forecast names.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.from_io_files">
<em class="property">classmethod </em><code class="sig-name descname">from_io_files</code><span class="sig-paren">(</span><em class="sig-param">tpl_files</em>, <em class="sig-param">in_files</em>, <em class="sig-param">ins_files</em>, <em class="sig-param">out_files</em>, <em class="sig-param">pst_filename=None</em>, <em class="sig-param">pst_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.from_io_files" title="Permalink to this definition">¶</a></dt>
<dd><p>create a Pst instance from model interface files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tpl_files</strong> ([<cite>str</cite>]) – list of template file names</p></li>
<li><p><strong>in_files</strong> ([<cite>str</cite>]) – list of model input file names (pairs with template files)</p></li>
<li><p><strong>ins_files</strong> ([<cite>str</cite>]) – list of instruction file names</p></li>
<li><p><strong>out_files</strong> ([<cite>str</cite>]) – list of model output file names (pairs with instruction files)</p></li>
<li><p><strong>pst_filename</strong> (<cite>str</cite>) – name of control file to write.  If None, no file is written.
Default is None</p></li>
<li><p><strong>pst_path</strong> (<em>'str'</em>) – the path from the control file to the IO files.  For example, if the
control will be in the same directory as the IO files, then <cite>pst_path</cite> should be ‘.’.
Default is None, which doesnt do any path manipulation on the I/O file names</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new control file instance with parameter and observation names
found in <cite>tpl_files</cite> and <cite>ins_files</cite>, repsectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Pst</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>calls <cite>pyemu.helpers.pst_from_io_files()</cite></p>
<p>Assigns generic values for parameter info.  Tries to use INSCHEK
to set somewhat meaningful observation values</p>
<p>all file paths are relatively to where python is running.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tpl_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;my.tpl&quot;</span><span class="p">]</span>
<span class="n">in_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;my.in&quot;</span><span class="p">]</span>
<span class="n">ins_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;my.ins&quot;</span><span class="p">]</span>
<span class="n">out_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;my.out&quot;</span><span class="p">]</span>
<span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="o">.</span><span class="n">from_io_files</span><span class="p">(</span><span class="n">tpl_files</span><span class="p">,</span><span class="n">in_files</span><span class="p">,</span><span class="n">ins_files</span><span class="p">,</span><span class="n">out_files</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">control_data</span><span class="o">.</span><span class="n">noptmax</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;my.pst)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.from_par_obs_names">
<em class="property">classmethod </em><code class="sig-name descname">from_par_obs_names</code><span class="sig-paren">(</span><em class="sig-param">par_names=['par1'], obs_names=['obs1']</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.from_par_obs_names" title="Permalink to this definition">¶</a></dt>
<dd><p>construct a shell <cite>Pst</cite> instance from parameter and observation names</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>par_names</strong> ([<cite>str</cite>]) – list of parameter names.  Default is [<cite>par1</cite>]</p></li>
<li><p><strong>obs_names</strong> ([<cite>str</cite>]) – list of observation names.  Default is [<cite>obs1</cite>]</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While this method works, it does not make template or instruction files.
Users are encouraged to use <cite>Pst.from_io_files()</cite> for more usefulness</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">par_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;par1&quot;</span><span class="p">,</span><span class="s2">&quot;par2&quot;</span><span class="p">]</span>
<span class="n">obs_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;obs1&quot;</span><span class="p">,</span><span class="s2">&quot;obs2&quot;</span><span class="p">]</span>
<span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="o">.</span><span class="n">from_par_obs_names</span><span class="p">(</span><span class="n">par_names</span><span class="p">,</span><span class="n">obs_names</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">par_names=None</em>, <em class="sig-param">obs_names=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a new pst object with subset of parameters and/or observations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>par_names</strong> ([<cite>str</cite>]) – a list of parameter names to have in the new Pst instance.
If None, all parameters are in the new Pst instance. Default
is None</p></li>
<li><p><strong>obs_names</strong> ([<cite>str</cite>]) – a list of observation names to have in the new Pst instance.
If None, all observations are in teh new Pst instance. Default
is None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new Pst instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Pst</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>passing <cite>par_names</cite> as <cite>None</cite> and <cite>obs_names</cite> as <cite>None</cite> effectively
generates a copy of the current <cite>Pst</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.get_adj_pars_at_bounds">
<code class="sig-name descname">get_adj_pars_at_bounds</code><span class="sig-paren">(</span><em class="sig-param">frac_tol=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.get_adj_pars_at_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>get list of adjustable parameter at/near bounds</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frac_tol</strong> (<em>'float`</em>) – fractional tolerance of distance to bound.  For upper bound,
the value <cite>parubnd * (1-frac_tol)</cite> is used, lower bound uses <cite>parlbnd * (1.0 + frac_tol)</cite></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>[`str`]</strong>: list of parameters at/near lower bound</p></li>
<li><p><strong>[`str`]</strong>: list of parameters at/near upper bound</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple containing</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.get_par_change_limits">
<code class="sig-name descname">get_par_change_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.get_par_change_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the various parameter change limits used in pest.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a copy of <cite>Pst.parameter_data</cite>
with columns for relative and factor change limits</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>does not yet support absolute parameter change limits!</p>
<p>Works in control file values space (not log transformed space).  Also
adds columns for effective upper and lower which account for par bounds and the
value of parchglim</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.get_res_stats">
<code class="sig-name descname">get_res_stats</code><span class="sig-paren">(</span><em class="sig-param">nonzero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.get_res_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>get some common residual stats by observation group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nonzero</strong> (<cite>bool</cite>) – calculate stats using only nonzero-weighted observations.  This may seem
obsvious to most users, but you never know….</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with columns for groups names and indices of statistic name.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pd.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Stats are derived from the current obsvals, weights and grouping in
<cite>Pst.observation_data</cite> and the <cite>modelled</cite> values in <cite>Pst.res</cite>.  The
key here is ‘current’ because if obsval, weights and/or groupings have
changed in <cite>Pst.observation_data</cite> since the residuals file was generated
then the current values for <cite>obsval</cite>, <cite>weight</cite> and <cite>group</cite> are used</p>
<p>the normalized RMSE is normalized against the obsval range (max - min)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.greater_than_obs_constraints">
<em class="property">property </em><code class="sig-name descname">greater_than_obs_constraints</code><a class="headerlink" href="#pyemu.pst.Pst.greater_than_obs_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>get the names of the observations that
are listed as active greater than inequality constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>names obseravtions that are non-zero weighted
greater than constraints (<cite>obgnme</cite> startsiwth “g_” or “greater”)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.Series</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zero-weighted obs are skipped</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.greater_than_pi_constraints">
<em class="property">property </em><code class="sig-name descname">greater_than_pi_constraints</code><a class="headerlink" href="#pyemu.pst.Pst.greater_than_pi_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>get the names of the prior information eqs that
are listed as active greater than inequality constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><cite>pandas.Series</cite> names of prior information that are non-zero weighted
greater than constraints (<cite>obgnme</cite> startsiwth “g_” or “greater”)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zero-weighted pi are skipped</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.less_than_obs_constraints">
<em class="property">property </em><code class="sig-name descname">less_than_obs_constraints</code><a class="headerlink" href="#pyemu.pst.Pst.less_than_obs_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>get the names of the observations that
are listed as active less than inequality constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>names of obseravtions that are non-zero weighted less
than constraints (<cite>obgnme</cite> starts with ‘l_’ or “less”)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.Series</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zero-weighted obs are skipped</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.less_than_pi_constraints">
<em class="property">property </em><code class="sig-name descname">less_than_pi_constraints</code><a class="headerlink" href="#pyemu.pst.Pst.less_than_pi_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>get the names of the prior information eqs that
are listed as active less than inequality constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>names of prior information that are non-zero weighted
less than constraints (<cite>obgnme</cite> starts with “l_” or “less”)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.Series</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zero-weighted pi are skipped</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.load" title="Permalink to this definition">¶</a></dt>
<dd><p>entry point load the pest control file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – pst filename</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is called from the <cite>Pst</cite> construtor unless the <cite>load</cite> arg is <cite>False</cite>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.nnz_obs">
<em class="property">property </em><code class="sig-name descname">nnz_obs</code><a class="headerlink" href="#pyemu.pst.Pst.nnz_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>get the number of non-zero weighted observations</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of non-zeros weighted observations</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.nnz_obs_groups">
<em class="property">property </em><code class="sig-name descname">nnz_obs_groups</code><a class="headerlink" href="#pyemu.pst.Pst.nnz_obs_groups" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the observation groups that contain at least one non-zero weighted</dt><dd><p>observation</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of observation groups that contain at
least one non-zero weighted observation</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.nnz_obs_names">
<em class="property">property </em><code class="sig-name descname">nnz_obs_names</code><a class="headerlink" href="#pyemu.pst.Pst.nnz_obs_names" title="Permalink to this definition">¶</a></dt>
<dd><p>get the non-zero weight observation names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of non-zero weighted observation names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.nobs">
<em class="property">property </em><code class="sig-name descname">nobs</code><a class="headerlink" href="#pyemu.pst.Pst.nobs" title="Permalink to this definition">¶</a></dt>
<dd><p>get the number of observations</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of observations</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.npar">
<em class="property">property </em><code class="sig-name descname">npar</code><a class="headerlink" href="#pyemu.pst.Pst.npar" title="Permalink to this definition">¶</a></dt>
<dd><p>get number of parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of parameters</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.npar_adj">
<em class="property">property </em><code class="sig-name descname">npar_adj</code><a class="headerlink" href="#pyemu.pst.Pst.npar_adj" title="Permalink to this definition">¶</a></dt>
<dd><p>get the number of adjustable parameters (not fixed or tied)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of adjustable parameters</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.nprior">
<em class="property">property </em><code class="sig-name descname">nprior</code><a class="headerlink" href="#pyemu.pst.Pst.nprior" title="Permalink to this definition">¶</a></dt>
<dd><p>number of prior information equations</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of prior info equations</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.obs_groups">
<em class="property">property </em><code class="sig-name descname">obs_groups</code><a class="headerlink" href="#pyemu.pst.Pst.obs_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>get the observation groups</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of unique observation groups</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.obs_names">
<em class="property">property </em><code class="sig-name descname">obs_names</code><a class="headerlink" href="#pyemu.pst.Pst.obs_names" title="Permalink to this definition">¶</a></dt>
<dd><p>get the observation names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of observation names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.pst.Pst.observation_data">
<code class="sig-name descname">observation_data</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.pst.Pst.observation_data" title="Permalink to this definition">¶</a></dt>
<dd><p>‘* observation data’ information.  Columns are standard PEST
variable names</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span><span class="o">.</span><span class="n">observation_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">pst</span><span class="o">.</span><span class="n">observation_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s2">&quot;obgnme&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;obs_group&quot;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.par_groups">
<em class="property">property </em><code class="sig-name descname">par_groups</code><a class="headerlink" href="#pyemu.pst.Pst.par_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parameter groups</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of parameter groups</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.par_names">
<em class="property">property </em><code class="sig-name descname">par_names</code><a class="headerlink" href="#pyemu.pst.Pst.par_names" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parameter names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of parameter names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.pst.Pst.parameter_data">
<code class="sig-name descname">parameter_data</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.pst.Pst.parameter_data" title="Permalink to this definition">¶</a></dt>
<dd><p>‘* parameter data’ information.  Columns are
standard PEST variable names</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span><span class="o">.</span><span class="n">parameter_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s2">&quot;partrans&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;log&quot;</span>
<span class="n">pst</span><span class="o">.</span><span class="n">parameter_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s2">&quot;parubnd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.parrep">
<code class="sig-name descname">parrep</code><span class="sig-paren">(</span><em class="sig-param">parfile=None</em>, <em class="sig-param">enforce_bounds=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.parrep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>replicates the pest parrep util. replaces the parval1 field in the</dt><dd><p>parameter data section dataframe with values in a PEST parameter file</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parfile</strong> (<cite>str</cite>, optional) – parameter file to use.  If None, try to find and use
a parameter file that corresponds to the case name.
Default is None</p></li>
<li><p><strong>enforce_bounds</strong> (<cite>bool</cite>, optional) – flag to enforce parameter bounds after parameter values are updated.
This is useful because PEST and PEST++ round the parameter values in the
par file, which may cause slight bound violations.  Default is <cite>True</cite></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.phi">
<em class="property">property </em><code class="sig-name descname">phi</code><a class="headerlink" href="#pyemu.pst.Pst.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>get the weighted total objective function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>sum of squared residuals</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>float</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires <cite>Pst.res</cite> (the residuals file) to be available</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.phi_components">
<em class="property">property </em><code class="sig-name descname">phi_components</code><a class="headerlink" href="#pyemu.pst.Pst.phi_components" title="Permalink to this definition">¶</a></dt>
<dd><p>get the individual components of the total objective function</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of observation group, contribution to total phi</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires <cite>Pst.res</cite> (the residuals file) to be available</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.phi_components_normalized">
<em class="property">property </em><code class="sig-name descname">phi_components_normalized</code><a class="headerlink" href="#pyemu.pst.Pst.phi_components_normalized" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the individual components of the total objective function</dt><dd><p>normalized to the total PHI being 1.0</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of observation group,
normalized contribution to total phi</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires <cite>Pst.res</cite> (the residuals file) to be available</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">kind=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>method to plot various parts of the control.  This is sweet as!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kind</strong> (<cite>str</cite>) – options are ‘prior’ (prior parameter histograms, ‘1to1’ (line of equality
and sim vs res), ‘obs_v_sim’ (time series using datetime suffix), ‘phi_pie’
(pie chart of phi components)</p></li>
<li><p><strong>kwargs</strong> (<cite>dict</cite>) – optional args for plots that are passed to pyemu plot helpers and ultimately
to matplotlib</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Depending on ‘kind’ argument, a multipage pdf is written</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;1to1&quot;</span><span class="p">)</span> <span class="c1"># requires Pst.res</span>
<span class="n">pst</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;prior&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;phi_pie&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.prior_groups">
<em class="property">property </em><code class="sig-name descname">prior_groups</code><a class="headerlink" href="#pyemu.pst.Pst.prior_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>get the prior info groups</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of prior information groups</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.pst.Pst.prior_information">
<code class="sig-name descname">prior_information</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.pst.Pst.prior_information" title="Permalink to this definition">¶</a></dt>
<dd><p>‘* prior information’ data.  Columns are standard PEST
variable names</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.prior_names">
<em class="property">property </em><code class="sig-name descname">prior_names</code><a class="headerlink" href="#pyemu.pst.Pst.prior_names" title="Permalink to this definition">¶</a></dt>
<dd><p>get the prior information names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of prior information names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.process_output_files">
<code class="sig-name descname">process_output_files</code><span class="sig-paren">(</span><em class="sig-param">pst_path='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.process_output_files" title="Permalink to this definition">¶</a></dt>
<dd><p>processing the model output files using the instruction files
and existing model output files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pst_path</strong> (<cite>str</cite>) – relative path from where python is running to
where the control file, instruction files and model output files
are located.  Default is “.” (current python directory)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>model output values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.Series</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>requires a complete set of model input files at relative path
from where python is running to <cite>pst_path</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.proportional_weights">
<code class="sig-name descname">proportional_weights</code><span class="sig-paren">(</span><em class="sig-param">fraction_stdev=1.0</em>, <em class="sig-param">wmax=100.0</em>, <em class="sig-param">leave_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.proportional_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>setup  weights inversely proportional to the observation value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fraction_stdev</strong> (<cite>float</cite>, optional) – the fraction portion of the observation
val to treat as the standard deviation.  set to 1.0 for
inversely proportional.  Default is 1.0</p></li>
<li><p><strong>wmax</strong> (<cite>float</cite>, optional) – maximum weight to allow.  Default is 100.0</p></li>
<li><p><strong>leave_zero</strong> (<cite>bool</cite>, optional) – flag to leave existing zero weights.
Default is True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.rectify_pgroups">
<code class="sig-name descname">rectify_pgroups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.rectify_pgroups" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronize parameter groups section with the parameter data section</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is called during <cite>Pst.write()</cite> to make sure all parameter
groups named in <cite>* parameter data</cite> are included.  This is so users
don’t have to manually keep this section up.  This method can also be
called during control file modifications to see what parameter groups
are present and prepare for modifying the default values in the <cite>* parameter
group</cite> section</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">parameter_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;par1&quot;</span><span class="p">,</span><span class="s2">&quot;pargp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;new_group&quot;</span>
<span class="n">pst</span><span class="o">.</span><span class="n">rectify_groups</span><span class="p">()</span>
<span class="n">pst</span><span class="o">.</span><span class="n">parameter_groups</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;new_group&quot;</span><span class="p">,</span><span class="s2">&quot;derinc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.rectify_pi">
<code class="sig-name descname">rectify_pi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.rectify_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>rectify the prior information equation with the current state of the
parameter_data dataframe.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Equations that list fixed, tied or missing parameters
are removed completely even if adjustable parameters are also
listed in the equation. This method is called during Pst.write()</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.pst.Pst.reg_data">
<code class="sig-name descname">reg_data</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.pst.Pst.reg_data" title="Permalink to this definition">¶</a></dt>
<dd><p>‘* regularization’ section information.
Access with standard PEST variable names.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span><span class="o">.</span><span class="n">reg_data</span><span class="o">.</span><span class="n">phimlim</span> <span class="o">=</span> <span class="mf">1.00</span> <span class="c1">#yeah right!</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pyemu.pst.pst_controldata.RegData</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.res">
<em class="property">property </em><code class="sig-name descname">res</code><a class="headerlink" href="#pyemu.pst.Pst.res" title="Permalink to this definition">¶</a></dt>
<dd><p>get the residuals dataframe attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe containing the
residuals information.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>if the Pst.__res attribute has not been loaded,</dt><dd><p>this call loads the res dataframe from a file</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.sanity_checks">
<code class="sig-name descname">sanity_checks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.sanity_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>some basic check for strangeness</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>checks for duplicate names, atleast 1 adjustable parameter
and at least 1 non-zero-weighted observation</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.set_res">
<code class="sig-name descname">set_res</code><span class="sig-paren">(</span><em class="sig-param">res</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.set_res" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the private <cite>Pst.res</cite> attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>res</strong> – (<cite>pandas.DataFrame</cite> or <cite>str</cite>): something to use as Pst.res attribute.
If <cite>res</cite> is <cite>str</cite>, a dataframe is read from file <cite>res</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.pst.Pst.svd_data">
<code class="sig-name descname">svd_data</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.pst.Pst.svd_data" title="Permalink to this definition">¶</a></dt>
<dd><p>‘* singular value decomposition’ section information.
Access with standard PEST variable names</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span><span class="o">.</span><span class="n">svd_data</span><span class="o">.</span><span class="n">maxsing</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>pyemu.pst.pst_controldata.SvdData</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.tied">
<em class="property">property </em><code class="sig-name descname">tied</code><a class="headerlink" href="#pyemu.pst.Pst.tied" title="Permalink to this definition">¶</a></dt>
<dd><p>list of tied parameter names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe of tied parameter information.
Columns of <cite>tied</cite> are <cite>parnme</cite> and <cite>partied</cite>.  Returns <cite>None</cite> if
no tied parameters are found.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">new_filename</em>, <em class="sig-param">version=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.write" title="Permalink to this definition">¶</a></dt>
<dd><p>main entry point to write a pest control file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_filename</strong> (<cite>str</cite>) – name of the new pest control file</p></li>
<li><p><strong>version</strong> (<cite>int</cite>) – flag for which version of control file to write (must be 1 or 2).
if None, uses Pst._version, which set in the constructor and modified
during the load</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">parrep</span><span class="p">(</span><span class="s2">&quot;my.par&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">my_new</span><span class="o">.</span><span class="n">pst</span><span class="s2">&quot;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.write_input_files">
<code class="sig-name descname">write_input_files</code><span class="sig-paren">(</span><em class="sig-param">pst_path='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.write_input_files" title="Permalink to this definition">¶</a></dt>
<dd><p>writes model input files using template files and current <cite>parval1</cite> values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pst_path</strong> (<cite>str</cite>) – the path to where control file and template files reside.
Default is ‘.’</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>adds “parval1_trans” column to Pst.parameter_data that includes the
effect of scale and offset</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>

<span class="c1"># load final parameter values</span>
<span class="n">pst</span><span class="o">.</span><span class="n">parrep</span><span class="p">(</span><span class="s2">&quot;my.par&quot;</span><span class="p">)</span>

<span class="c1"># write new model input files with final parameter values</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write_input_files</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.write_obs_summary_table">
<code class="sig-name descname">write_obs_summary_table</code><span class="sig-paren">(</span><em class="sig-param">filename=None</em>, <em class="sig-param">group_names=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.write_obs_summary_table" title="Permalink to this definition">¶</a></dt>
<dd><p>write a stand alone observation summary latex table</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – latex filename. If <cite>filename</cite> is “none”, no table is written.
If None, use &lt;case&gt;.par.tex. Default is None</p></li>
<li><p><strong>group_names</strong> (<cite>dict</cite>) – obs group names : table names. For example {“hds”:”simulated groundwater level”}.
Default is None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the summary observation group dataframe</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write_obs_summary_table</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;obs.tex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.write_par_summary_table">
<code class="sig-name descname">write_par_summary_table</code><span class="sig-paren">(</span><em class="sig-param">filename=None</em>, <em class="sig-param">group_names=None</em>, <em class="sig-param">sigma_range=4.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.pst.Pst.write_par_summary_table" title="Permalink to this definition">¶</a></dt>
<dd><p>write a stand alone parameter summary latex table</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – latex filename. If None, use &lt;case&gt;.par.tex. If <cite>filename</cite> is “none”, no table
is writtenDefault is None</p></li>
<li><p><strong>group_names</strong> (<cite>dict</cite>) – par group names : table names. For example {“w0”:”well stress period 1”}.
Default is None</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>) – number of standard deviations represented by parameter bounds.  Default
is 4.0, implying 95% confidence bounds</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the summary parameter group dataframe</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write_par_summary_table</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;par.tex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.pst.Pst.zero_weight_obs_names">
<em class="property">property </em><code class="sig-name descname">zero_weight_obs_names</code><a class="headerlink" href="#pyemu.pst.Pst.zero_weight_obs_names" title="Permalink to this definition">¶</a></dt>
<dd><p>get the zero-weighted observation names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of zero-weighted observation names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyemu.mat"></span><p>This module contains classes for handling matrices in a linear algebra setting.
The primary objects are the <cite>Matrix</cite> and <cite>Cov</cite>.  These objects overload most numerical
operators to autoalign the elements based on row and column names.</p>
<dl class="class">
<dt id="pyemu.mat.Matrix">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.mat.</code><code class="sig-name descname">Matrix</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">row_names=[]</em>, <em class="sig-param">col_names=[]</em>, <em class="sig-param">isdiagonal=False</em>, <em class="sig-param">autoalign=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Easy linear algebra in the PEST(++) realm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>numpy.ndarray</cite>) – numeric values</p></li>
<li><p><strong>row_names</strong> ([<cite>str</cite>]) – list of row names</p></li>
<li><p><strong>col_names</strong> (<em>[</em><em>'str'</em><em>]</em>) – list of column names</p></li>
<li><p><strong>isdigonal</strong> (<cite>bool</cite>) – flag if the Matrix is diagonal</p></li>
<li><p><strong>autoalign</strong> (<cite>bool</cite>) – flag to control the autoalignment of Matrix
during linear algebra operations</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">row_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;row_</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;col_</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">row_names</span><span class="o">=</span><span class="n">row_names</span><span class="p">,</span><span class="n">col_names</span><span class="o">=</span><span class="n">col_names</span><span class="p">)</span>
<span class="n">mat</span><span class="o">.</span><span class="n">to_binary</span><span class="p">(</span><span class="s2">&quot;mat.jco&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this class makes heavy use of property decorators to encapsulate
private attributes</p>
</div>
<dl class="method">
<dt id="pyemu.mat.Matrix.T">
<em class="property">property </em><code class="sig-name descname">T</code><a class="headerlink" href="#pyemu.mat.Matrix.T" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper function for <cite>Matrix.transpose()</cite> method</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>transpose of <cite>Matrix</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.align">
<code class="sig-name descname">align</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.align" title="Permalink to this definition">¶</a></dt>
<dd><p>reorder <cite>Matrix</cite> by names in place.  If axis is None, reorder both indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> (<em>[</em><em>'str'</em><em>]</em>) – names in <cite>Matrix.row_names</cite> andor <cite>Matrix.col_names</cite></p></li>
<li><p><strong>axis</strong> (<cite>int</cite>, optional) – the axis to reorder. if None, reorder both axes</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.as_2d">
<em class="property">property </em><code class="sig-name descname">as_2d</code><a class="headerlink" href="#pyemu.mat.Matrix.as_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>get a 2D numeric representation of <cite>Matrix.x</cite>.  If not <cite>isdiagonal</cite>, simply
return reference to <cite>Matrix.x</cite>, otherwise, constructs and returns
a 2D, diagonal ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.mat.Matrix.char">
<code class="sig-name descname">char</code><a class="headerlink" href="#pyemu.mat.Matrix.char" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.uint8</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>get a copy of <cite>Matrix</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>copy of this <cite>Matrix</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.df">
<code class="sig-name descname">df</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.df" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper of Matrix.to_dataframe()</p>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.mat.Matrix.double">
<code class="sig-name descname">double</code><a class="headerlink" href="#pyemu.mat.Matrix.double" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float64</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.drop">
<code class="sig-name descname">drop</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">axis</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>drop elements from <cite>Matrix</cite> in place</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> (<em>[</em><em>'str'</em><em>]</em>) – list of names to drop</p></li>
<li><p><strong>axis</strong> (<cite>int</cite>) – the axis to drop from. must be in [0,1]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.element_isaligned">
<code class="sig-name descname">element_isaligned</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.element_isaligned" title="Permalink to this definition">¶</a></dt>
<dd><p>check if matrices are aligned for element-wise operations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<cite>Matrix</cite>) – the other matrix to check for alignment with</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if aligned, False if not aligned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>extend <cite>Matrix</cite> with the elements of other.</p>
<p>Args:
other (<cite>Matrix</cite>):  the Matrix to extend self by
inplace (<cite>bool</cite>): inplace = True not implemented</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>new, extended <cite>Matrix</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">row_names=None</em>, <em class="sig-param">col_names=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper method that <cite>Matrix.gets()</cite> then <cite>Matrix.drops()</cite> elements.
one of row_names or col_names must be not None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>row_names</strong> (<em>[</em><em>'str'</em><em>]</em><em>, </em><em>optional</em>) – row_names to extract.  If <cite>None</cite>,
all row_names are retained.</p></li>
<li><p><strong>col_names</strong> (<em>[</em><em>'str'</em><em>]</em><em>, </em><em>optional</em>) – col_names to extract. If <cite>None</cite>,
all col_names are retained.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the extract sub-matrix defined by <cite>row_names</cite> and/or <cite>col_names</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.find_rowcol_indices">
<em class="property">static </em><code class="sig-name descname">find_rowcol_indices</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">row_names</em>, <em class="sig-param">col_names</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.find_rowcol_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>fast(er) look of row and colum names indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> ([<cite>str</cite>]) – list of names to look for in <cite>row_names</cite> and/or <cite>col_names</cite> names</p></li>
<li><p><strong>row_names</strong> ([<cite>str</cite>]) – list of row names</p></li>
<li><p><strong>col_names</strong> ([<cite>str</cite>]) – list of column names</p></li>
<li><p><strong>axis</strong> (<cite>int</cite>, optional) – axis to search along.  If None, search both.
Default is <cite>None</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of (integer) index locations.  If <cite>axis</cite> is
<cite>None</cite>, a 2 <cite>numpy.ndarrays</cite> of both row and column name indices is returned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.from_ascii">
<em class="property">classmethod </em><code class="sig-name descname">from_ascii</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.from_ascii" title="Permalink to this definition">¶</a></dt>
<dd><p>load a PEST-compatible ASCII matrix/vector file into a
<cite>Matrix</cite> instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – name of the file to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>Matrix</cite> loaded from ASCII file</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_ascii</span><span class="p">(</span><span class="s2">&quot;my.mat&quot;</span><span class="p">)</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">pyemi</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_ascii</span><span class="p">(</span><span class="s2">&quot;my.cov&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.from_binary">
<em class="property">classmethod </em><code class="sig-name descname">from_binary</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.from_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>class method load from PEST-compatible binary file into a
Matrix instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – filename to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>Matrix</cite> loaded from binary file</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_binary</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">pyemi</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_binary</span><span class="p">(</span><span class="s2">&quot;large_cov.jcb&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.from_dataframe">
<em class="property">classmethod </em><code class="sig-name descname">from_dataframe</code><span class="sig-paren">(</span><em class="sig-param">df</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.from_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>class method to create a new <cite>Matrix</cite> instance from a</dt><dd><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>df</strong> (<cite>pandas.DataFrame</cite>) – dataframe</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>Matrix</cite> instance derived from <cite>df</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;my.csv&quot;</span><span class="p">)</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.from_fortranfile">
<em class="property">static </em><code class="sig-name descname">from_fortranfile</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.from_fortranfile" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>a binary load method to accommodate one of the many</dt><dd><p>bizarre fortran binary writing formats</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – name of the binary matrix file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>numpy.ndarray</strong>: the numeric values in the file</p></li>
<li><p><strong>[‘str’]</strong>: list of row names</p></li>
<li><p><strong>[`str`]</strong>: list of col_names</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.from_names">
<em class="property">classmethod </em><code class="sig-name descname">from_names</code><span class="sig-paren">(</span><em class="sig-param">row_names</em>, <em class="sig-param">col_names</em>, <em class="sig-param">isdiagonal=False</em>, <em class="sig-param">autoalign=True</em>, <em class="sig-param">random=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.from_names" title="Permalink to this definition">¶</a></dt>
<dd><p>class method to create a new Matrix instance from
row names and column names, filled with trash</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>row_names</strong> (<em>[</em><em>'str'</em><em>]</em>) – row names for the new <cite>Matrix</cite></p></li>
<li><p><strong>col_names</strong> (<em>[</em><em>'str'</em><em>]</em>) – col_names for the new matrix</p></li>
<li><p><strong>isdiagonal</strong> (<cite>bool</cite>, optional) – flag for diagonal matrix. Default is False</p></li>
<li><p><strong>autoalign</strong> (<cite>bool</cite>, optional) – flag for autoaligning new matrix
during linear algebra calcs. Default is True</p></li>
<li><p><strong>random</strong> (<cite>bool</cite>) – flag for contents of the trash matrix.
If True, fill with random numbers, if False, fill with zeros
Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new Matrix instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.full_s">
<em class="property">property </em><code class="sig-name descname">full_s</code><a class="headerlink" href="#pyemu.mat.Matrix.full_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the full singular value matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>full singular value matrix.  Shape is <cite>(max(Matrix.shape),max(Matrix.shape))</cite>
with zeros along the diagonal from <cite>min(Matrix.shape)</cite> to <cite>max(Matrix.shape)</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">row_names=None</em>, <em class="sig-param">col_names=None</em>, <em class="sig-param">drop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a new <cite>Matrix</cite> instance ordered on row_names or col_names</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>row_names</strong> (<em>[</em><em>'str'</em><em>]</em><em>, </em><em>optional</em>) – row_names for new Matrix.  If <cite>None</cite>,
all row_names are used.</p></li>
<li><p><strong>col_names</strong> (<em>[</em><em>'str'</em><em>]</em><em>, </em><em>optional</em>) – col_names for new Matrix. If <cite>None</cite>,
all col_names are used.</p></li>
<li><p><strong>drop</strong> (<cite>bool</cite>) – flag to remove row_names and/or col_names from this <cite>Matrix</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new <cite>Matrix</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.get_diagonal_vector">
<code class="sig-name descname">get_diagonal_vector</code><span class="sig-paren">(</span><em class="sig-param">col_name='diag'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.get_diagonal_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new Matrix instance that is the diagonal of self.  The
shape of the new matrix is (self.shape[0],1).  Self must be square</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>col_name</strong> (<cite>str</cite>) – the name of the single column in the new Matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>vector-shaped <cite>Matrix</cite> instance of the diagonal of this <cite>Matrix</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.get_maxsing">
<code class="sig-name descname">get_maxsing</code><span class="sig-paren">(</span><em class="sig-param">eigthresh=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.get_maxsing" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of singular components with a singular
value ratio greater than or equal to eigthresh</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>eigthresh (<cite>float</cite>): the ratio of smallest to largest</dt><dd><p>singular value to retain.  Since it is assumed that
<cite>s</cite> is sorted from largest to smallest, once a singular value
is reached that yields a ratio with the first (largest)
singular value, the index of this singular is returned.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the index of the singular value whos ratio with the
first singular value is less than or equal to <cite>eigthresh</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this method calls the static method <cite>Matrix.get_maxsing_from_s()</cite>
with <cite>Matrix.s.x</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.get_maxsing_from_s">
<em class="property">static </em><code class="sig-name descname">get_maxsing_from_s</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">eigthresh=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.get_maxsing_from_s" title="Permalink to this definition">¶</a></dt>
<dd><p>static method to work out the maxsing for a
given singular spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> (<cite>numpy.ndarray</cite>) – 1-D array of singular values. This
array should come from calling either <cite>numpy.linalg.svd</cite>
or from the <cite>pyemu.Matrix.s.x</cite> attribute</p></li>
<li><p><strong>eigthresh</strong> (<cite>float</cite>) – the ratio of smallest to largest
singular value to retain.  Since it is assumed that
<cite>s</cite> is sorted from largest to smallest, once a singular value
is reached that yields a ratio with the first (largest)
singular value, the index of this singular is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the index of the singular value whos ratio with the
first singular value is less than or equal to <cite>eigthresh</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.hadamard_product">
<code class="sig-name descname">hadamard_product</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.hadamard_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload of numpy.ndarray.__mult__(): element-wise multiplication.
Tries to speedup by checking for scalars of diagonal matrices on
either side of operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – (<cite>int</cite>,`float`,`numpy.ndarray`,`Matrix`): the thing to multiply</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the result of multiplication</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if <cite>Matrix</cite> and other (if applicable) have <cite>autoalign</cite> set to <cite>True</cite>,
both <cite>Matrix</cite> and <cite>other</cite> are aligned based on row and column names.
If names are not common between the two, this may result in a smaller
returned <cite>Matrix</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.indices">
<code class="sig-name descname">indices</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.indices" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the row and col indices of names. If axis is None, two ndarrays</dt><dd><p>are returned, corresponding the indices of names for each axis</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> ([<cite>str</cite>]) – list of names to look for in <cite>row_names</cite> and/or <cite>col_names</cite> names</p></li>
<li><p><strong>row_names</strong> ([<cite>str</cite>]) – list of row names</p></li>
<li><p><strong>col_names</strong> ([<cite>str</cite>]) – list of column names</p></li>
<li><p><strong>axis</strong> (<cite>int</cite>, optional) – axis to search along.  If None, search both.
Default is <cite>None</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of (integer) index locations.  If <cite>axis</cite> is
<cite>None</cite>, a 2 <cite>numpy.ndarrays</cite> of both row and column name indices is returned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>thin wrapper around <cite>Matrix.find_rowcol_indices</cite> static method</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.mat.Matrix.integer">
<code class="sig-name descname">integer</code><a class="headerlink" href="#pyemu.mat.Matrix.integer" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.int32</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.inv">
<em class="property">property </em><code class="sig-name descname">inv</code><a class="headerlink" href="#pyemu.mat.Matrix.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>inversion operation of <cite>Matrix</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>inverse of <cite>Matrix</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>uses <cite>numpy.linalg.inv</cite> for the inversion</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_binary</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">mat_inv</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">inv</span>
<span class="n">mat_inv</span><span class="o">.</span><span class="n">to_binary</span><span class="p">(</span><span class="s2">&quot;my_inv.jco&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.mult_isaligned">
<code class="sig-name descname">mult_isaligned</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.mult_isaligned" title="Permalink to this definition">¶</a></dt>
<dd><p>check if matrices are aligned for dot product multiplication</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<cite>Matrix</cite>) – the other matrix to check for alignment with</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if aligned, False if not aligned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.ncol">
<em class="property">property </em><code class="sig-name descname">ncol</code><a class="headerlink" href="#pyemu.mat.Matrix.ncol" title="Permalink to this definition">¶</a></dt>
<dd><p>length of second dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of columns</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.newx">
<em class="property">property </em><code class="sig-name descname">newx</code><a class="headerlink" href="#pyemu.mat.Matrix.newx" title="Permalink to this definition">¶</a></dt>
<dd><p>return a copy of <cite>Matrix.x</cite> attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a copy <cite>Matrix.x</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.nrow">
<em class="property">property </em><code class="sig-name descname">nrow</code><a class="headerlink" href="#pyemu.mat.Matrix.nrow" title="Permalink to this definition">¶</a></dt>
<dd><p>length of first dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of rows</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.pseudo_inv">
<code class="sig-name descname">pseudo_inv</code><span class="sig-paren">(</span><em class="sig-param">maxsing=None</em>, <em class="sig-param">eigthresh=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.pseudo_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>The pseudo inverse of self.  Formed using truncated singular
value decomposition and <cite>Matrix.pseudo_inv_components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxsing</strong> (<cite>int</cite>, optional) – the number of singular components to use.  If None,
<cite>maxsing</cite> is calculated using <cite>Matrix.get_maxsing()</cite> and <cite>eigthresh</cite></p></li>
<li><p><strong>eigthresh</strong> – (<cite>float</cite>, optional): the ratio of largest to smallest singular
components to use for truncation.  Ignored if maxsing is not None.  Default is
1.0e-5</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the truncated-SVD pseudo inverse of <cite>Matrix</cite> (V_1 * s_1^-1 * U^T)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.pseudo_inv_components">
<code class="sig-name descname">pseudo_inv_components</code><span class="sig-paren">(</span><em class="sig-param">maxsing=None</em>, <em class="sig-param">eigthresh=1e-05</em>, <em class="sig-param">truncate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.pseudo_inv_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the (optionally) truncated SVD components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxsing</strong> (<cite>int</cite>, optional) – the number of singular components to use.  If None,
<cite>maxsing</cite> is calculated using <cite>Matrix.get_maxsing()</cite> and <cite>eigthresh</cite></p></li>
<li><p><strong>eigthresh</strong> – (<cite>float</cite>, optional): the ratio of largest to smallest singular
components to use for truncation.  Ignored if maxsing is not None.  Default is
1.0e-5</p></li>
<li><p><strong>truncate</strong> (<cite>bool</cite>) – flag to truncate components. If False, U, s, and V will be
zeroed out at locations greater than <cite>maxsing</cite> instead of truncated. Default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>Matrix</strong>: (optionally truncated) left singular vectors</p></li>
<li><p><strong>Matrix</strong>: (optionally truncated) singular value matrix</p></li>
<li><p><strong>Matrix</strong>: (optionally truncated) right singular vectors</p></li>
</ul>
</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">from_binary</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">pseudo_inv_components</span><span class="p">(</span><span class="n">maxsing</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">resolution_matrix</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span>
<span class="n">resolution_matrix</span><span class="o">.</span><span class="n">to_ascii</span><span class="p">(</span><span class="s2">&quot;resol.mat&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.read_ascii">
<em class="property">static </em><code class="sig-name descname">read_ascii</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.read_ascii" title="Permalink to this definition">¶</a></dt>
<dd><p>read a PEST-compatible ASCII matrix/vector file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – file to read from</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>numpy.ndarray</strong>: numeric values</p></li>
<li><p><strong>[‘str’]</strong>: list of row names</p></li>
<li><p><strong>[`str`]</strong>: list of column names</p></li>
<li><p><strong>bool</strong>: diagonal flag</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.read_binary">
<em class="property">static </em><code class="sig-name descname">read_binary</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.read_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>static method to read PEST-format binary files</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – filename to read</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>numpy.ndarray</strong>: the numeric values in the file</p></li>
<li><p><strong>[‘str’]</strong>: list of row names</p></li>
<li><p><strong>[`str`]</strong>: list of col_names</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.reset_x">
<code class="sig-name descname">reset_x</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.reset_x" title="Permalink to this definition">¶</a></dt>
<dd><p>reset self.__x private attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>numpy.ndarray</cite>) – the new numeric data</p></li>
<li><p><strong>copy</strong> (<cite>bool</cite>) – flag to make a copy of ‘x’. Defaule is True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.s">
<em class="property">property </em><code class="sig-name descname">s</code><a class="headerlink" href="#pyemu.mat.Matrix.s" title="Permalink to this definition">¶</a></dt>
<dd><p>the singular value (diagonal) Matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>singular value matrix.  shape is <cite>(min(Matrix.shape),min(Matrix.shape))</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#pyemu.mat.Matrix.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>get the implied, 2D shape of <cite>Matrix</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>length of 2 tuple</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.sqrt">
<em class="property">property </em><code class="sig-name descname">sqrt</code><a class="headerlink" href="#pyemu.mat.Matrix.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>element-wise square root operation</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>element-wise square root of <cite>Matrix</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>uses <cite>numpy.sqrt</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.to_2d">
<code class="sig-name descname">to_2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.to_2d" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get a 2D <cite>Matrix</cite> representation of <cite>Matrix</cite>.  If not <cite>Matrix.isdiagonal</cite>, simply</dt><dd><p>return a copy of <cite>Matrix</cite>, otherwise, constructs and returns a new <cite>Matrix</cite>
instance that is stored as diagonal</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>non-diagonal form of <cite>Matrix</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Martrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.to_ascii">
<code class="sig-name descname">to_ascii</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">icode=2</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.to_ascii" title="Permalink to this definition">¶</a></dt>
<dd><p>write a PEST-compatible ASCII Matrix/vector file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – filename to write to</p>
</dd>
</dl>
<dl class="simple">
<dt>icode (<cite>int</cite>, optional): PEST-style info code for matrix style.</dt><dd><p>Default is 2</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.to_binary">
<code class="sig-name descname">to_binary</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">droptol=None</em>, <em class="sig-param">chunk=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.to_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>write a PEST-compatible binary file.  The format is the same
as the format used to storage a PEST Jacobian matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – filename to save binary file</p></li>
<li><p><strong>droptol</strong> (<cite>float</cite>) – absolute value tolerance to make values
smaller <cite>droptol</cite> than zero.  Default is None (no dropping)</p></li>
<li><p><strong>chunk</strong> (<cite>int</cite>) – number of elements to write in a single pass.
Default is <cite>None</cite>, which writes the entire numeric part of the
<cite>Matrix</cite> at once. This is faster but requires more memory.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.to_coo">
<code class="sig-name descname">to_coo</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">droptol=None</em>, <em class="sig-param">chunk=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.to_coo" title="Permalink to this definition">¶</a></dt>
<dd><p>write an extended PEST-format binary file.  The data format is
[int,int,float] for i,j,value.  It is autodetected during
the read with <cite>Matrix.from_binary()</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – filename to save binary file</p></li>
<li><p><strong>droptol</strong> (<cite>float</cite>) – absolute value tolerance to make values
smaller <cite>droptol</cite> than zero.  Default is None (no dropping)</p></li>
<li><p><strong>chunk</strong> (<cite>int</cite>) – number of elements to write in a single pass.
Default is <cite>None</cite>, which writes the entire numeric part of the
<cite>Matrix</cite> at once. This is faster but requires more memory.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.to_dataframe">
<code class="sig-name descname">to_dataframe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Matrix.to_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>return a pandas.DataFrame representation of <cite>Matrix</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe derived from <cite>Matrix</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.transpose">
<em class="property">property </em><code class="sig-name descname">transpose</code><a class="headerlink" href="#pyemu.mat.Matrix.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>transpose operation of self</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>transpose of <cite>Matrix</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.u">
<em class="property">property </em><code class="sig-name descname">u</code><a class="headerlink" href="#pyemu.mat.Matrix.u" title="Permalink to this definition">¶</a></dt>
<dd><p>the left singular vector Matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>left singular vectors.  Shape is <cite>(Matrix.shape[0], Matrix.shape[0])</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.v">
<em class="property">property </em><code class="sig-name descname">v</code><a class="headerlink" href="#pyemu.mat.Matrix.v" title="Permalink to this definition">¶</a></dt>
<dd><p>the right singular vector Matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>right singular vectors.  Shape is <cite>(Matrix.shape[1], Matrix.shape[1])</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.x">
<em class="property">property </em><code class="sig-name descname">x</code><a class="headerlink" href="#pyemu.mat.Matrix.x" title="Permalink to this definition">¶</a></dt>
<dd><p>return a reference to <cite>Matrix.x</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>reference to <cite>Matrix.x</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Matrix.zero2d">
<em class="property">property </em><code class="sig-name descname">zero2d</code><a class="headerlink" href="#pyemu.mat.Matrix.zero2d" title="Permalink to this definition">¶</a></dt>
<dd><p>get an 2D instance of self with all zeros</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><cite>Matrix of zeros</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyemu.mat.Jco">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.mat.</code><code class="sig-name descname">Jco</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">row_names=[]</em>, <em class="sig-param">col_names=[]</em>, <em class="sig-param">isdiagonal=False</em>, <em class="sig-param">autoalign=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Jco" title="Permalink to this definition">¶</a></dt>
<dd><p>a thin wrapper class to get more intuitive attribute names.  Functions
exactly like <cite>Matrix</cite></p>
<dl class="method">
<dt id="pyemu.mat.Jco.from_pst">
<em class="property">classmethod </em><code class="sig-name descname">from_pst</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">random=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Jco.from_pst" title="Permalink to this definition">¶</a></dt>
<dd><p>construct a new empty Jco from a control file filled
with trash</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a pest control file instance.  If type is ‘str’,
<cite>pst</cite> is loaded from filename</p></li>
<li><p><strong>random</strong> (<cite>bool</cite>) – flag for contents of the trash matrix.
If True, fill with random numbers, if False, fill with zeros
Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new Jco instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Jco</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Jco.nobs">
<em class="property">property </em><code class="sig-name descname">nobs</code><a class="headerlink" href="#pyemu.mat.Jco.nobs" title="Permalink to this definition">¶</a></dt>
<dd><p>number of observations in the Jco</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of observations (rows)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Jco.npar">
<em class="property">property </em><code class="sig-name descname">npar</code><a class="headerlink" href="#pyemu.mat.Jco.npar" title="Permalink to this definition">¶</a></dt>
<dd><p>number of parameters in the Jco</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of parameters (columns)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>int</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Jco.obs_names">
<em class="property">property </em><code class="sig-name descname">obs_names</code><a class="headerlink" href="#pyemu.mat.Jco.obs_names" title="Permalink to this definition">¶</a></dt>
<dd><p>thin wrapper around <cite>Matrix.row_names</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of observation names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[‘str’]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Jco.par_names">
<em class="property">property </em><code class="sig-name descname">par_names</code><a class="headerlink" href="#pyemu.mat.Jco.par_names" title="Permalink to this definition">¶</a></dt>
<dd><p>thin wrapper around <cite>Matrix.col_names</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of parameter names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyemu.mat.Cov">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.mat.</code><code class="sig-name descname">Cov</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">names=[]</em>, <em class="sig-param">row_names=[]</em>, <em class="sig-param">col_names=[]</em>, <em class="sig-param">isdiagonal=False</em>, <em class="sig-param">autoalign=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal and/or dense Covariance matrices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>numpy.ndarray</cite>) – numeric values</p></li>
<li><p><strong>names</strong> ([<cite>str</cite>]) – list of row and column names</p></li>
<li><p><strong>isdigonal</strong> (<cite>bool</cite>) – flag if the Matrix is diagonal</p></li>
<li><p><strong>autoalign</strong> (<cite>bool</cite>) – flag to control the autoalignment of Matrix during
linear algebra operations</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;par_</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Cov</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
<span class="n">mat</span><span class="o">.</span><span class="n">to_binary</span><span class="p">(</span><span class="s2">&quot;mat.jco&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>row_names</cite> and <cite>col_names</cite> args are supported in the contructor
so support inheritance.  However, users should only pass <cite>names</cite></p>
</div>
<dl class="method">
<dt id="pyemu.mat.Cov.condition_on">
<code class="sig-name descname">condition_on</code><span class="sig-paren">(</span><em class="sig-param">conditioning_elements</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.condition_on" title="Permalink to this definition">¶</a></dt>
<dd><p>get a new Covariance object that is conditional on knowing some
elements.  uses Schur’s complement for conditional Covariance
propagation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>conditioning_elements</strong> (<em>[</em><em>'str'</em><em>]</em>) – list of names of elements to condition on</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new conditional <cite>Cov</cite> that assumes <cite>conditioning_elements</cite> have become known</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.from_observation_data">
<em class="property">classmethod </em><code class="sig-name descname">from_observation_data</code><span class="sig-paren">(</span><em class="sig-param">pst</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.from_observation_data" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiates a <cite>Cov</cite> from pyemu.Pst.observation_data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – control file instance</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a diagonal observation noise covariance matrix derived from the
weights in the pest control file.  Zero-weighted observations
are included with a weight of 1.0e-30</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Cov</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">obscov</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_observation_data</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.from_obsweights">
<em class="property">classmethod </em><code class="sig-name descname">from_obsweights</code><span class="sig-paren">(</span><em class="sig-param">pst_file</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.from_obsweights" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiates a <cite>Cov</cite> instance from observation weights in
a PEST control file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pst_file</strong> (<cite>str</cite>) – pest control file name</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a diagonal observation noise covariance matrix derived from the
weights in the pest control file.  Zero-weighted observations
are included with a weight of 1.0e-30</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Cov</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls <cite>Cov.from_observation_data()</cite></p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">obscov</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_obsweights</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.from_parameter_data">
<em class="property">classmethod </em><code class="sig-name descname">from_parameter_data</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">sigma_range=4.0</em>, <em class="sig-param">scale_offset=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.from_parameter_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiates a <cite>Cov</cite> from a pest control file parameter data section using
parameter bounds as a proxy for uncertainty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst_file</strong> (<cite>str</cite>) – pest control file name</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>) – defines range of upper bound - lower bound in terms of standard
deviation (sigma). For example, if sigma_range = 4, the bounds
represent 4 * sigma.  Default is 4.0, representing approximately
95% confidence of implied normal distribution</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>) – flag to apply scale and offset to parameter upper and lower
bounds before calculating varaince. In some cases, not applying scale and
offset can result in undefined (log) variance.  Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>diagonal parameter <cite>Cov</cite> matrix created from parameter bounds</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Cov</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls <cite>Cov.from_parameter_data()</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.from_parbounds">
<em class="property">classmethod </em><code class="sig-name descname">from_parbounds</code><span class="sig-paren">(</span><em class="sig-param">pst_file</em>, <em class="sig-param">sigma_range=4.0</em>, <em class="sig-param">scale_offset=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.from_parbounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiates a <cite>Cov</cite> from a pest control file parameter data section using
parameter bounds as a proxy for uncertainty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst_file</strong> (<cite>str</cite>) – pest control file name</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>) – defines range of upper bound - lower bound in terms of standard
deviation (sigma). For example, if sigma_range = 4, the bounds
represent 4 * sigma.  Default is 4.0, representing approximately
95% confidence of implied normal distribution</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>) – flag to apply scale and offset to parameter upper and lower
bounds before calculating varaince. In some cases, not applying scale and
offset can result in undefined (log) variance.  Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>diagonal parameter <cite>Cov</cite> matrix created from parameter bounds</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Cov</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls <cite>Cov.from_parameter_data()</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.from_uncfile">
<em class="property">classmethod </em><code class="sig-name descname">from_uncfile</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.from_uncfile" title="Permalink to this definition">¶</a></dt>
<dd><p>instaniates a <cite>Cov</cite> from a PEST-compatible uncertainty file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – uncertainty file name</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>Cov</cite> instance from uncertainty file</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Cov</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cov</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_uncfile</span><span class="p">(</span><span class="s2">&quot;my.unc&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.identity">
<em class="property">property </em><code class="sig-name descname">identity</code><a class="headerlink" href="#pyemu.mat.Cov.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>get an identity <cite>Cov</cite> of the same shape</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>new <cite>Cov</cite> instance with identity matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.identity_like">
<em class="property">classmethod </em><code class="sig-name descname">identity_like</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.identity_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an identity matrix Cov instance like other <cite>Cov</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> (<cite>Matrix</cite>) – other matrix - must be square</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new identity matrix <cite>Cov</cite> with shape of <cite>other</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.names">
<em class="property">property </em><code class="sig-name descname">names</code><a class="headerlink" href="#pyemu.mat.Cov.names" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for getting row_names.  row_names == col_names for Cov</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace elements in the covariance matrix with elements from other.
if other is not diagonal, then this <cite>Cov</cite> becomes non diagonal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Cov</strong> – the Cov to replace elements in this <cite>Cov</cite> with</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>operates in place</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.to_pearson">
<code class="sig-name descname">to_pearson</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.to_pearson" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Cov instance to Pearson correlation coefficient
matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>Matrix</cite> of correlation coefs.  Return type is <cite>Matrix</cite>
on purpose so that it is clear the returned instance is not a Cov</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.to_uncfile">
<code class="sig-name descname">to_uncfile</code><span class="sig-paren">(</span><em class="sig-param">unc_file</em>, <em class="sig-param">covmat_file='cov.mat'</em>, <em class="sig-param">var_mult=1.0</em>, <em class="sig-param">include_path=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.mat.Cov.to_uncfile" title="Permalink to this definition">¶</a></dt>
<dd><p>write a PEST-compatible uncertainty file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unc_file</strong> (<cite>str</cite>) – filename of the uncertainty file</p></li>
<li><p><strong>covmat_file</strong> (<cite>str</cite>) – covariance matrix filename. Default is
“Cov.mat”.  If None, and Cov.isdiaonal, then a standard deviation
form of the uncertainty file is written.  Exception raised if <cite>covmat_file</cite> is <cite>None</cite>
and not <cite>Cov.isdiagonal</cite></p></li>
<li><p><strong>var_mult</strong> (<cite>float</cite>) – variance multiplier for the covmat_file entry</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cov</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_parameter_data</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">cov</span><span class="o">.</span><span class="n">to_uncfile</span><span class="p">(</span><span class="s2">&quot;my.unc&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.mat.Cov.zero">
<em class="property">property </em><code class="sig-name descname">zero</code><a class="headerlink" href="#pyemu.mat.Cov.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>get an instance of <cite>Cov</cite> with all zeros</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>new <cite>Cov</cite> instance with zeros</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Cov</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyemu.la"></span><p>LinearAnalysis object, which is the base class for other
pyemu analysis objects (Schur, ErrVar, MonteCarlo, and EnsembleSmoother).
This class is usually not used directly.</p>
<dl class="class">
<dt id="pyemu.la.LinearAnalysis">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.la.</code><code class="sig-name descname">LinearAnalysis</code><span class="sig-paren">(</span><em class="sig-param">jco=None</em>, <em class="sig-param">pst=None</em>, <em class="sig-param">parcov=None</em>, <em class="sig-param">obscov=None</em>, <em class="sig-param">predictions=None</em>, <em class="sig-param">ref_var=1.0</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">resfile=False</em>, <em class="sig-param">forecasts=None</em>, <em class="sig-param">sigma_range=4.0</em>, <em class="sig-param">scale_offset=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>The base/parent class for linear analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>jco</strong> (<em>varies</em><em>, </em><em>optional</em>) – something that can be cast or loaded into a <cite>pyemu.Jco</cite>.  Can be a
str for a filename or <cite>pyemu.Matrix</cite>/<cite>pyemu.Jco</cite> object.</p></li>
<li><p><strong>pst</strong> (<em>varies</em><em>, </em><em>optional</em>) – something that can be cast into a <cite>pyemu.Pst</cite>.  Can be an <cite>str</cite> for a
filename or an existing <cite>pyemu.Pst</cite>.  If <cite>None</cite>, a pst filename is sought
with the same base name as the jco argument (if passed)</p></li>
<li><p><strong>parcov</strong> (<em>varies</em><em>, </em><em>optional</em>) – prior parameter covariance matrix.  If <cite>str</cite>, a filename is assumed and
the prior parameter covariance matrix is loaded from a file using
the file extension (“.jcb”/”.jco” for binary, “.cov”/”.mat” for PEST-style ASCII matrix,
or “.unc” for uncertainty files).  If <cite>None</cite>, the prior parameter covariance matrix is
constructed from the parameter bounds in <cite>LinearAnalysis.pst</cite>.  Can also be a <cite>pyemu.Cov</cite> instance</p></li>
<li><p><strong>obscov</strong> (<em>varies</em><em>, </em><em>optional</em>) – observation noise covariance matrix.  If <cite>str</cite>, a filename is assumed and
the noise covariance matrix is loaded from a file using
the file extension (“.jcb”/”.jco” for binary, “.cov”/”.mat” for PEST-style ASCII matrix,
or “.unc” for uncertainty files).  If <cite>None</cite>, the noise covariance matrix is
constructed from the obsevation weights in <cite>LinearAnalysis.pst</cite>.  Can also be a <cite>pyemu.Cov</cite> instance</p></li>
<li><p><strong>forecasts</strong> (<em>varies</em><em>, </em><em>optional</em>) – forecast sensitivity vectors.  If <cite>str</cite>, first an observation name is assumed (a row
in <cite>LinearAnalysis.jco</cite>).  If that is not found, a filename is assumed and predictions are
loaded from a file using the file extension.  If [<cite>str</cite>], a list of observation names is assumed.
Can also be a <cite>pyemu.Matrix</cite> instance, a <cite>numpy.ndarray</cite> or a collection
of <cite>pyemu.Matrix</cite> or <cite>numpy.ndarray</cite>.</p></li>
<li><p><strong>ref_var</strong> (<em>float</em><em>, </em><em>optional</em>) – reference variance.  Default is 1.0</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>) – controls screen output.  If <cite>str</cite>, a filename is assumed and
and log file is written.</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>, optional) – defines range of upper bound - lower bound in terms of standard
deviation (sigma). For example, if sigma_range = 4, the bounds represent 4 * sigma.
Default is 4.0, representing approximately 95% confidence of implied normal distribution.
This arg is only used if constructing parcov from parameter bounds.</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>, optional) – flag to apply parameter scale and offset to parameter bounds
when calculating prior parameter covariance matrix from bounds.  This arg is onlyused if
constructing parcov from parameter bounds.Default is True.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Can be used directly, but for prior uncertainty analyses only.</p>
<p>The derived types (<cite>pyemu.Schur</cite>, <cite>pyemu.ErrVar</cite>) are for different
forms of FOMS-based posterior uncertainty analyses.</p>
<p>This class tries hard to not load items until they are needed; all arguments are optional.</p>
<p>The class makes heavy use of property decorator to encapsulated private attributes</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#assumes &quot;my.pst&quot; exists</span>
<span class="n">la</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">LinearAnalysis</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">,</span><span class="n">forecasts</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="s2">&quot;fore2&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">la</span><span class="o">.</span><span class="n">prior_forecast</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.la.LinearAnalysis.adj_par_names">
<em class="property">property </em><code class="sig-name descname">adj_par_names</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.adj_par_names" title="Permalink to this definition">¶</a></dt>
<dd><p>adjustable parameter names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of adjustable parameter names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[‘str`]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if <cite>LinearAnalysis.pst</cite> is <cite>None</cite>, returns <cite>LinearAnalysis.jco.col_names</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.adjust_obscov_resfile">
<code class="sig-name descname">adjust_obscov_resfile</code><span class="sig-paren">(</span><em class="sig-param">resfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.adjust_obscov_resfile" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the elements of obscov by scaling the implied weights
based on the phi components in res_file so that the total phi
is equal to the number of non-zero weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>resfile</strong> (<cite>str</cite>) – residual file to use.  If None, residual
file with case name is sought. default is None</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>calls <cite>pyemu.Pst.adjust_weights_resfile()</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.apply_karhunen_loeve_scaling">
<code class="sig-name descname">apply_karhunen_loeve_scaling</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.apply_karhunen_loeve_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>apply karhuene-loeve scaling to the jacobian matrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This scaling is not necessary for analyses using Schur’s
complement, but can be very important for error variance
analyses.  This operation effectively transfers prior knowledge
specified in the parcov to the jacobian and reset parcov to the
identity matrix.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.clean">
<code class="sig-name descname">clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>drop regularization and prior information observation from the jco</p>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.drop_prior_information">
<code class="sig-name descname">drop_prior_information</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.drop_prior_information" title="Permalink to this definition">¶</a></dt>
<dd><p>drop the prior information from the jco and pst attributes</p>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.fehalf">
<em class="property">property </em><code class="sig-name descname">fehalf</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.fehalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Karhunen-Loeve scaling matrix attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the Karhunen-Loeve scaling matrix based on the prior
parameter covariance matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.forecast_names">
<em class="property">property </em><code class="sig-name descname">forecast_names</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.forecast_names" title="Permalink to this definition">¶</a></dt>
<dd><p>get the forecast (aka prediction) names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of forecast names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>([<cite>str</cite>])</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.forecasts">
<em class="property">property </em><code class="sig-name descname">forecasts</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.forecasts" title="Permalink to this definition">¶</a></dt>
<dd><p>the forecast sentivity vectors attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a matrix of forecast (prediction) sensitivity vectors (column wise)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.forecasts_iter">
<em class="property">property </em><code class="sig-name descname">forecasts_iter</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.forecasts_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>forecast (e.g. prediction) sensitivity vectors iterator</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>iterator on forecasts (e.g. predictions) sensitivity vectors (matrix)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>iterator</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is used for processing huge numbers of predictions</p>
<p>This is a synonym for LinearAnalysis.predictions_iter()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">par_names=None</em>, <em class="sig-param">obs_names=None</em>, <em class="sig-param">astype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.get" title="Permalink to this definition">¶</a></dt>
<dd><p>method to get a new LinearAnalysis class using a
subset of parameters and/or observations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>par_names</strong> ([<cite>‘str</cite>]) – par names for new object</p></li>
<li><p><strong>obs_names</strong> ([<cite>‘str</cite>]) – obs names for new object</p></li>
<li><p><strong>astype</strong> (<cite>pyemu.Schur</cite> or <cite>pyemu.ErrVar</cite>) – type to
cast the new object.  If None, return type is
same as self</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>LinearAnalysis</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.get_cso_dataframe">
<code class="sig-name descname">get_cso_dataframe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.get_cso_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>get a dataframe of composite observation sensitivity, as returned by PEST in the
seo file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dataframe of observation names and composite observation
sensitivity</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>That this formulation deviates slightly from the PEST documentation in that the
values are divided by (npar-1) rather than by (npar).</p>
<p>The equation is cso_j = ((Q^1/2*J*J^T*Q^1/2)^1/2)_jj/(NPAR-1)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.get_obs_competition_dataframe">
<code class="sig-name descname">get_obs_competition_dataframe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.get_obs_competition_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>get the observation competition stat a la PEST utility</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe of observation names by
observation names with values equal to the PEST
competition statistic</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.get_par_css_dataframe">
<code class="sig-name descname">get_par_css_dataframe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.get_par_css_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>get a dataframe of composite scaled sensitivities.  Includes both
PEST-style and Hill-style.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe of parameter names, PEST-style and
Hill-style composite scaled sensitivity</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.jco">
<em class="property">property </em><code class="sig-name descname">jco</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.jco" title="Permalink to this definition">¶</a></dt>
<dd><p>the jacobian matrix attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the jacobian matrix attribute</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Jco</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.mle_covariance">
<em class="property">property </em><code class="sig-name descname">mle_covariance</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.mle_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum likelihood parameter covariance matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>maximum likelihood parameter covariance matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.mle_parameter_estimate">
<em class="property">property </em><code class="sig-name descname">mle_parameter_estimate</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.mle_parameter_estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum likelihood parameter estimate.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the maximum likelihood parameter estimates</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.Series</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.nnz_obs_names">
<em class="property">property </em><code class="sig-name descname">nnz_obs_names</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.nnz_obs_names" title="Permalink to this definition">¶</a></dt>
<dd><p>non-zero-weighted observation names</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of non-zero-weighted observation names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[‘str`]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if <cite>LinearAnalysis.pst</cite> is <cite>None</cite>, returns <cite>LinearAnalysis.jco.row_names</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.obscov">
<em class="property">property </em><code class="sig-name descname">obscov</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.obscov" title="Permalink to this definition">¶</a></dt>
<dd><p>get the observation noise covariance matrix attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a reference to the <cite>LinearAnalysis.obscov</cite> attribute</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.parcov">
<em class="property">property </em><code class="sig-name descname">parcov</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.parcov" title="Permalink to this definition">¶</a></dt>
<dd><p>get the prior parameter covariance matrix attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a reference to the <cite>LinearAnalysis.parcov</cite> attribute</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.predictions">
<em class="property">property </em><code class="sig-name descname">predictions</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.predictions" title="Permalink to this definition">¶</a></dt>
<dd><p>the prediction (aka forecast) sentivity vectors attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a matrix of prediction sensitivity vectors (column wise)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.predictions_iter">
<em class="property">property </em><code class="sig-name descname">predictions_iter</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.predictions_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>prediction sensitivity vectors iterator</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>iterator on prediction sensitivity vectors (matrix)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>iterator</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this is used for processing huge numbers of predictions</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.prior_forecast">
<em class="property">property </em><code class="sig-name descname">prior_forecast</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.prior_forecast" title="Permalink to this definition">¶</a></dt>
<dd><p>prior forecast (e.g. prediction) variances</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dictionary of forecast name, prior variance pairs</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.prior_parameter">
<em class="property">property </em><code class="sig-name descname">prior_parameter</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.prior_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>prior parameter covariance matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>prior parameter covariance matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.prior_prediction">
<em class="property">property </em><code class="sig-name descname">prior_prediction</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.prior_prediction" title="Permalink to this definition">¶</a></dt>
<dd><p>prior prediction (e.g. forecast) variances</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dictionary of prediction name, prior variance pairs</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.pst">
<em class="property">property </em><code class="sig-name descname">pst</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.pst" title="Permalink to this definition">¶</a></dt>
<dd><p>the pst attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the pst attribute</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Pst</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.qhalf">
<em class="property">property </em><code class="sig-name descname">qhalf</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.qhalf" title="Permalink to this definition">¶</a></dt>
<dd><p>square root of the cofactor matrix attribute. Create the attribute if
it has not yet been created</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>square root of the cofactor matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.qhalfx">
<em class="property">property </em><code class="sig-name descname">qhalfx</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.qhalfx" title="Permalink to this definition">¶</a></dt>
<dd><p>half normal matrix attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>half normal matrix attribute</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.reset_obscov">
<code class="sig-name descname">reset_obscov</code><span class="sig-paren">(</span><em class="sig-param">arg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.reset_obscov" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the obscov attribute to None</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> (<cite>str</cite> or <cite>pyemu.Matrix</cite>) – the value to assign to the obscov
attribute.  If None, the private __obscov attribute is cleared
but not reset</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.reset_parcov">
<code class="sig-name descname">reset_parcov</code><span class="sig-paren">(</span><em class="sig-param">arg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.reset_parcov" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the parcov attribute to None</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> (<cite>str</cite> or <cite>pyemu.Matrix</cite>) – the value to assign to the parcov
attribute.  If None, the private __parcov attribute is cleared
but not reset</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.reset_pst">
<code class="sig-name descname">reset_pst</code><span class="sig-paren">(</span><em class="sig-param">arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.la.LinearAnalysis.reset_pst" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the LinearAnalysis.pst attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> (<cite>str</cite> or <cite>pyemu.Pst</cite>) – the value to assign to the pst attribute</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.la.LinearAnalysis.xtqx">
<em class="property">property </em><code class="sig-name descname">xtqx</code><a class="headerlink" href="#pyemu.la.LinearAnalysis.xtqx" title="Permalink to this definition">¶</a></dt>
<dd><p>normal matrix attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>normal matrix attribute</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyemu.sc"></span><p>module for FOSM-based uncertainty analysis using a
linearized form of Bayes equation known as the Schur compliment</p>
<dl class="class">
<dt id="pyemu.sc.Schur">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.sc.</code><code class="sig-name descname">Schur</code><span class="sig-paren">(</span><em class="sig-param">jco</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur" title="Permalink to this definition">¶</a></dt>
<dd><p>FOSM-based uncertainty and data-worth analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>jco</strong> (<em>varies</em><em>, </em><em>optional</em>) – something that can be cast or loaded into a <cite>pyemu.Jco</cite>.  Can be a
str for a filename or <cite>pyemu.Matrix</cite>/<cite>pyemu.Jco</cite> object.</p></li>
<li><p><strong>pst</strong> (<em>varies</em><em>, </em><em>optional</em>) – something that can be cast into a <cite>pyemu.Pst</cite>.  Can be an <cite>str</cite> for a
filename or an existing <cite>pyemu.Pst</cite>.  If <cite>None</cite>, a pst filename is sought
with the same base name as the jco argument (if passed)</p></li>
<li><p><strong>parcov</strong> (<em>varies</em><em>, </em><em>optional</em>) – prior parameter covariance matrix.  If <cite>str</cite>, a filename is assumed and
the prior parameter covariance matrix is loaded from a file using
the file extension (“.jcb”/”.jco” for binary, “.cov”/”.mat” for PEST-style ASCII matrix,
or “.unc” for uncertainty files).  If <cite>None</cite>, the prior parameter covariance matrix is
constructed from the parameter bounds in <cite>LinearAnalysis.pst</cite>.  Can also be a <cite>pyemu.Cov</cite> instance</p></li>
<li><p><strong>obscov</strong> (<em>varies</em><em>, </em><em>optional</em>) – observation noise covariance matrix.  If <cite>str</cite>, a filename is assumed and
the noise covariance matrix is loaded from a file using
the file extension (“.jcb”/”.jco” for binary, “.cov”/”.mat” for PEST-style ASCII matrix,
or “.unc” for uncertainty files).  If <cite>None</cite>, the noise covariance matrix is
constructed from the obsevation weights in <cite>LinearAnalysis.pst</cite>.  Can also be a <cite>pyemu.Cov</cite> instance</p></li>
<li><p><strong>forecasts</strong> (<em>varies</em><em>, </em><em>optional</em>) – forecast sensitivity vectors.  If <cite>str</cite>, first an observation name is assumed (a row
in <cite>LinearAnalysis.jco</cite>).  If that is not found, a filename is assumed and predictions are
loaded from a file using the file extension.  If [<cite>str</cite>], a list of observation names is assumed.
Can also be a <cite>pyemu.Matrix</cite> instance, a <cite>numpy.ndarray</cite> or a collection.  Note if the PEST++ option
“++forecasts()” is set in the pest control file (under the <cite>pyemu.Pst.pestpp_options</cite> dictionary),
then there is no need to pass this argument (unless you want to analyze different forecasts)
of <cite>pyemu.Matrix</cite> or <cite>numpy.ndarray</cite>.</p></li>
<li><p><strong>ref_var</strong> (<em>float</em><em>, </em><em>optional</em>) – reference variance.  Default is 1.0</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>) – controls screen output.  If <cite>str</cite>, a filename is assumed and
and log file is written.</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>, optional) – defines range of upper bound - lower bound in terms of standard
deviation (sigma). For example, if sigma_range = 4, the bounds represent 4 * sigma.
Default is 4.0, representing approximately 95% confidence of implied normal distribution.
This arg is only used if constructing parcov from parameter bounds.</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>, optional) – flag to apply parameter scale and offset to parameter bounds
when calculating prior parameter covariance matrix from bounds.  This arg is onlyused if
constructing parcov from parameter bounds.Default is True.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is the primary entry point for FOSM-based uncertainty and
dataworth analyses</p>
<p>This class replicates and extends the behavior of the PEST PREDUNC utilities.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#assumes &quot;my.pst&quot; exists</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">,</span><span class="n">forecasts</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="s2">&quot;fore2&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">get_forecast_summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">get_parameter_contribution</span><span class="p">())</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.sc.Schur.get_added_obs_group_importance">
<code class="sig-name descname">get_added_obs_group_importance</code><span class="sig-paren">(</span><em class="sig-param">reset_zero_weight=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_added_obs_group_importance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dataworth method to analyze the posterior uncertainty as a result of gaining</dt><dd><p>existing observations, tested by observation groups</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dataframe with index of observation group names and columns
of forecast names.  The values in the dataframe are the posterior
variances of the forecasts resulting from gaining the information
contained in each observation group. One row in the dataframe is labeled “base” - this is
posterior forecast variance resulting from the notional calibration with the
non-zero-weighed observations in <cite>Schur.pst</cite>.  Conceptually, the forecast variance should
either not change or decrease as a result of gaining new observations.  The magnitude
of the decrease represents the worth of the potential new observation(s) in each group
being tested.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Observations in <cite>Schur.pst</cite> with zero weights are not included in the analysis unless
<cite>reset_zero_weight</cite> is <cite>True</cite> or a float greater than zero.  In most cases, users
will want to reset zero-weighted observations as part dataworth testing process.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_added_obs_group_importance</span><span class="p">(</span><span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_added_obs_importance">
<code class="sig-name descname">get_added_obs_importance</code><span class="sig-paren">(</span><em class="sig-param">obslist_dict=None</em>, <em class="sig-param">base_obslist=None</em>, <em class="sig-param">reset_zero_weight=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_added_obs_importance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dataworth method to analyze the posterior uncertainty as a result of gathering</dt><dd><p>some additional observations</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obslist_dict</strong> (<cite>dict</cite>, optional) – a nested dictionary-list of groups of observations
that are to be treated as gained/collected.  key values become
row labels in returned dataframe. If <cite>None</cite>, then every zero-weighted
observation is tested sequentially. Default is <cite>None</cite></p></li>
<li><p><strong>base_obslist</strong> ([<cite>str</cite>], optional) – observation names to treat as the “existing” observations.
The values of <cite>obslist_dict</cite> will be added to this list during
each test.  If <cite>None</cite>, then the values in each <cite>obslist_dict</cite> entry will
be treated as the entire calibration dataset.  That is, there
are no existing observations. Default is <cite>None</cite>.  Standard practice would
be to pass this argument as <cite>pyemu.Schur.pst.nnz_obs_names</cite> so that existing,
non-zero-weighted observations are accounted for in evaluating the worth of
new yet-to-be-collected observations.</p></li>
<li><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with row labels (index) of <cite>obslist_dict.keys()</cite> and
columns of forecast names.  The values in the dataframe are the
posterior variance of the forecasts resulting from notional inversion
using the observations in <cite>obslist_dict[key value]</cite> plus the observations
in <cite>base_obslist</cite> (if any).  One row in the dataframe is labeled “base” - this is
posterior forecast variance resulting from the notional calibration with the
observations in <cite>base_obslist</cite> (if <cite>base_obslist</cite> is <cite>None</cite>, then the “base” row is the
prior forecast variance).  Conceptually, the forecast variance should either not change or
decrease as a result of gaining additional observations.  The magnitude of the decrease
represents the worth of the potential new observation(s) being tested.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Observations listed in <cite>obslist_dict</cite> and <cite>base_obslist</cite> with zero
weights are not included in the analysis unless <cite>reset_zero_weight</cite> is <cite>True</cite> or a float
greater than zero.  In most cases, users will want to reset zero-weighted observations as part
dataworth testing process.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">obslist_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;hds&quot;</span><span class="p">:[</span><span class="s2">&quot;head1&quot;</span><span class="p">,</span><span class="s2">&quot;head2&quot;</span><span class="p">],</span><span class="s2">&quot;flux&quot;</span><span class="p">:[</span><span class="s2">&quot;flux1&quot;</span><span class="p">,</span><span class="s2">&quot;flux2&quot;</span><span class="p">]}</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_added_obs_importance</span><span class="p">(</span><span class="n">obslist_dict</span><span class="o">=</span><span class="n">obslist_dict</span><span class="p">,</span>
                                 <span class="n">base_obslist</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">pst</span><span class="o">.</span><span class="n">nnz_obs_names</span><span class="p">,</span>
                                 <span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_conditional_instance">
<code class="sig-name descname">get_conditional_instance</code><span class="sig-paren">(</span><em class="sig-param">parameter_names</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_conditional_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>get a new <cite>pyemu.Schur</cite> instance that includes conditional update from
some parameters becoming known perfectly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>parameter_names</strong> ([<cite>str</cite>]) – list of parameters that are to be treated as
notionally perfectly known</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new Schur instance conditional on perfect knowledge
of some parameters. The new instance has an updated <cite>parcov</cite> that is less
the names listed in <cite>parameter_names</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Schur</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is primarily for use by the <cite>LinearAnalysis.get_parameter_contribution()</cite>
dataworth method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_forecast_summary">
<code class="sig-name descname">get_forecast_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_forecast_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>summary of the FOSM-based forecast uncertainty (variance) estimate(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dataframe of prior,posterior variances and percent
uncertainty reduction of each forecast (e.g. prediction)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the primary entry point for accessing forecast uncertainty estimates
“precent_reduction” column in dataframe is calculated as
100.0 * (1.0 - (posterior variance / prior variance)</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jcb&quot;</span><span class="p">,</span><span class="n">forecasts</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="s2">&quot;fore2&quot;</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_parameter_summary</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s2">&quot;prior&quot;</span><span class="p">,</span><span class="s2">&quot;posterior&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">percent_reduction</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_obs_group_dict">
<code class="sig-name descname">get_obs_group_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_obs_group_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>get a dictionary of observations grouped by observation group name</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dictionary of observations grouped by observation group name.
Useful for dataworth processing in <cite>pyemu.Schur</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>only includes observations that are listed in <cite>Schur.jco.row_names</cite></p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">obsgrp_dict</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_obs_group_dict</span><span class="p">()</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_removed_obs_importance</span><span class="p">(</span><span class="n">obsgrp_dict</span><span class="o">=</span><span class="n">obsgrp_dict</span><span class="p">,</span> <span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_par_contribution">
<code class="sig-name descname">get_par_contribution</code><span class="sig-paren">(</span><em class="sig-param">parlist_dict=None</em>, <em class="sig-param">include_prior_results=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_par_contribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A dataworth method to get a dataframe the prior and posterior uncertainty
reduction as a result of some parameter becoming perfectly known</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parlist_dict</strong> – (<cite>dict</cite>, optional): a nested dictionary-list of groups of parameters
that are to be treated as perfectly known.  key values become
row labels in returned dataframe.  If <cite>None</cite>, each adjustable parameter
is sequentially treated as known and the returned dataframe
has row labels for each adjustable parameter</p></li>
<li><p><strong>include_prior_results</strong> (<cite>bool</cite>, optional) – flag to return a multi-indexed dataframe with both conditional
prior and posterior forecast uncertainty estimates.  This is because
the notional learning about parameters potentially effects both the prior
and posterior forecast uncertainty estimates. If <cite>False</cite>, only posterior
results are returned.  Default is <cite>False</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe that summarizes the parameter contribution
dataworth analysis. The dataframe has index (row labels) of the keys in parlist_dict
and a column labels of forecast names.  The values in the dataframe
are the posterior variance of the forecast conditional on perfect
knowledge of the parameters in the values of parlist_dict.  One row in the
dataframe will be labeled <cite>base</cite> - this is the forecast uncertainty estimates
that include the effects of all adjustable parameters.  Percent decreases in
forecast uncertainty can be calculated by differencing all rows against the
“base” row.  Varies depending on <cite>include_prior_results</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the primary dataworth method for assessing the contribution of one or more
parameters to forecast uncertainty.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">parlist_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;hk&quot;</span><span class="p">:[</span><span class="s2">&quot;hk1&quot;</span><span class="p">,</span><span class="s2">&quot;hk2&quot;</span><span class="p">],</span><span class="s2">&quot;rech&quot;</span><span class="p">[</span><span class="s2">&quot;rech1&quot;</span><span class="p">,</span><span class="s2">&quot;rech2&quot;</span><span class="p">]}</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_par_contribution</span><span class="p">(</span><span class="n">parlist_dict</span><span class="o">=</span><span class="n">parlist_dict</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_par_group_contribution">
<code class="sig-name descname">get_par_group_contribution</code><span class="sig-paren">(</span><em class="sig-param">include_prior_results=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_par_group_contribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A dataworth method to get the forecast uncertainty contribution from each parameter
group</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>include_prior_results</strong> (<cite>bool</cite>, optional) – flag to return a multi-indexed dataframe with both conditional
prior and posterior forecast uncertainty estimates.  This is because
the notional learning about parameters potentially effects both the prior
and posterior forecast uncertainty estimates. If <cite>False</cite>, only posterior
results are returned.  Default is <cite>False</cite></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe that summarizes the parameter contribution analysis.
The dataframe has index (row labels) that are the parameter group names
and a column labels of forecast names.  The values in the dataframe
are the posterior variance of the forecast conditional on perfect
knowledge of the adjustable parameters in each parameter group.  One
row is labelled “base” - this is the variance of the forecasts that includes
the effects of all adjustable parameters. Varies depending on <cite>include_prior_results</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is just a thin wrapper around get_contribution_dataframe() - this method
automatically constructs the parlist_dict argument where the keys are the
group names and the values are the adjustable parameters in the groups</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_par_group_contribution</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_parameter_summary">
<code class="sig-name descname">get_parameter_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_parameter_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>summary of the FOSM-based parameter uncertainty (variance) estimate(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dataframe of prior,posterior variances and percent
uncertainty reduction of each parameter</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the primary entry point for accessing parameter uncertainty estimates</p>
<p>The “Prior” column in dataframe is the diagonal of <cite>LinearAnalysis.parcov</cite>
“precent_reduction” column in dataframe is calculated as 100.0 * (1.0 -
(posterior variance / prior variance)</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jcb&quot;</span><span class="p">,</span><span class="n">forecasts</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="s2">&quot;fore2&quot;</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_parameter_summary</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s2">&quot;prior&quot;</span><span class="p">,</span><span class="s2">&quot;posterior&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">percent_reduction</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_removed_obs_group_importance">
<code class="sig-name descname">get_removed_obs_group_importance</code><span class="sig-paren">(</span><em class="sig-param">reset_zero_weight=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_removed_obs_group_importance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dataworth method to analyze the posterior uncertainty as a result of losing</dt><dd><p>existing observations, tested by observation groups</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dataframe with index of observation group names and columns
of forecast names.  The values in the dataframe are the posterior
variances of the forecasts resulting from losing the information
contained in each observation group. One row in the dataframe is labeled “base” - this is
posterior forecast variance resulting from the notional calibration with the
non-zero-weighed observations in <cite>Schur.pst</cite>.  Conceptually, the forecast variance should
either not change or increase as a result of losing existing observations.  The magnitude
of the increase represents the worth of the existing observation(s) in each group being tested.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Observations in <cite>Schur.pst</cite> with zero weights are not included in the analysis unless
<cite>reset_zero_weight</cite> is <cite>True</cite> or a float greater than zero.  In most cases, users
will want to reset zero-weighted observations as part dataworth testing process.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_removed_obs_group_importance</span><span class="p">(</span><span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.get_removed_obs_importance">
<code class="sig-name descname">get_removed_obs_importance</code><span class="sig-paren">(</span><em class="sig-param">obslist_dict=None</em>, <em class="sig-param">reset_zero_weight=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.get_removed_obs_importance" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dataworth method to analyze the posterior uncertainty as a result of losing</dt><dd><p>some existing observations</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obslist_dict</strong> (<cite>dict</cite>, optional) – a nested dictionary-list of groups of observations
that are to be treated as lost.  key values become
row labels in returned dataframe. If <cite>None</cite>, then every zero-weighted
observation is tested sequentially. Default is <cite>None</cite></p></li>
<li><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dataframe with index of obslist_dict.keys() and columns
of forecast names.  The values in the dataframe are the posterior
variances of the forecasts resulting from losing the information
contained in obslist_dict[key value]. One row in the dataframe is labeled “base” - this is
posterior forecast variance resulting from the notional calibration with the
non-zero-weighed observations in <cite>Schur.pst</cite>.  Conceptually, the forecast variance should
either not change or increase as a result of losing existing observations.  The magnitude
of the increase represents the worth of the existing observation(s) being tested.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Observations listed in <cite>obslist_dict</cite> and <cite>base_obslist</cite> with zero
weights are not included in the analysis unless <cite>reset_zero_weight</cite> is <cite>True</cite> or a float
greater than zero.  In most cases, users will want to reset zero-weighted observations as part
dataworth testing process.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_removed_obs_importance</span><span class="p">(</span><span class="n">reset_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.next_most_important_added_obs">
<code class="sig-name descname">next_most_important_added_obs</code><span class="sig-paren">(</span><em class="sig-param">forecast=None</em>, <em class="sig-param">niter=3</em>, <em class="sig-param">obslist_dict=None</em>, <em class="sig-param">base_obslist=None</em>, <em class="sig-param">reset_zero_weight=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.next_most_important_added_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>find the most important observation(s) by sequentially evaluating
the importance of the observations in <cite>obslist_dict</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>forecast</strong> (<cite>str</cite>, optional) – name of the forecast to use in the ranking process.  If
more than one forecast has been listed, this argument is required.  This is because
the data worth must be ranked with respect to the variance reduction for a single
forecast</p></li>
<li><p><strong>niter</strong> (<cite>int</cite>, optional) – number of sequential dataworth testing iterations.  Default is 3</p></li>
<li><p><strong>obslist_dict</strong> (<cite>dict</cite>, optional) – a nested dictionary-list of groups of observations
that are to be treated as gained/collected.  key values become
row labels in returned dataframe. If <cite>None</cite>, then every zero-weighted
observation is tested sequentially. Default is <cite>None</cite></p></li>
<li><p><strong>base_obslist</strong> ([<cite>str</cite>], optional) – observation names to treat as the “existing” observations.
The values of <cite>obslist_dict</cite> will be added to this list during
each test.  If <cite>None</cite>, then the values in each <cite>obslist_dict</cite> entry will
be treated as the entire calibration dataset.  That is, there
are no existing observations. Default is <cite>None</cite>.  Standard practice would
be to pass this argument as <cite>pyemu.Schur.pst.nnz_obs_names</cite> so that existing,
non-zero-weighted observations are accounted for in evaluating the worth of
new yet-to-be-collected observations.</p></li>
<li><p><strong>reset_zero_weight</strong> (<cite>bool</cite>, optional) – a flag to reset observations with zero weight in either
<cite>obslist_dict</cite> or <cite>base_obslist</cite>. If <cite>reset_zero_weights</cite>
passed as a <cite>float</cite>,then that value will be assigned to
zero weight obs.  Otherwise, zero-weight obs will be given a
weight of 1.0.  Default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataFrame with columns of <cite>obslist_dict</cite> key for each iteration
the yields the largest variance reduction for the named <cite>forecast</cite>. Columns are forecast
variance percent reduction for each iteration (percent reduction compared to initial “base”
case with all non-zero weighted observations included in the notional calibration)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The most important observations from each iteration is added to <cite>base_obslist</cite>
and removed <cite>obslist_dict</cite> for the next iteration.  In this way, the added
observation importance values include the conditional information from
the last iteration.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">next_most_important_added_obs</span><span class="p">(</span><span class="n">forecast</span><span class="o">=</span><span class="s2">&quot;fore1&quot;</span><span class="p">,</span><span class="n">base_obslist</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">pst</span><span class="o">.</span><span class="n">nnz_obs_names</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.next_most_par_contribution">
<code class="sig-name descname">next_most_par_contribution</code><span class="sig-paren">(</span><em class="sig-param">niter=3</em>, <em class="sig-param">forecast=None</em>, <em class="sig-param">parlist_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.sc.Schur.next_most_par_contribution" title="Permalink to this definition">¶</a></dt>
<dd><p>find the parameter(s) contributing most to posterior
forecast  by sequentially evaluating the contribution of parameters in
<cite>parlist_dict</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>forecast</strong> (<cite>str</cite>, optional) – name of the forecast to use in the ranking process.  If
more than one forecast has been listed, this argument is required.  This is because
the data worth must be ranked with respect to the variance reduction for a single
forecast</p></li>
<li><p><strong>niter</strong> (<cite>int</cite>, optional) – number of sequential dataworth testing iterations.  Default is 3</p></li>
<li><p><strong>parlist_dict</strong> (<cite>dict</cite>, optional) – dict
a nested dictionary-list of groups of parameters
that are to be treated as perfectly known.  key values become
row labels in dataframe</p></li>
<li><p><strong>parlist_dict</strong> – a nested dictionary-list of groups of parameters
that are to be treated as perfectly known (zero uncertainty).  key values become
row labels in returned dataframe. If <cite>None</cite>, then every adustable parameter is tested
sequentially. Default is <cite>None</cite>. Conceptually, the forecast variance should
either not change or decrease as a result of knowing parameter perfectly.  The magnitude
of the decrease represents the worth of gathering information about the parameter(s) being
tested.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The largest contributing parameters from each iteration are
treated as known perfectly for the remaining iterations.  In this way, the
next iteration seeks the next most influential group of parameters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe with index of iteration number and columns
of <cite>parlist_dict.keys()</cite>.  The values are the results of the knowing
each parlist_dict entry expressed as posterior variance reduction</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.posterior_forecast">
<em class="property">property </em><code class="sig-name descname">posterior_forecast</code><a class="headerlink" href="#pyemu.sc.Schur.posterior_forecast" title="Permalink to this definition">¶</a></dt>
<dd><p>posterior forecast (e.g. prediction) variance(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of forecast names and FOSM-estimated posterior
variances</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sames as <cite>LinearAnalysis.posterior_prediction</cite></p>
<p>See <cite>Schur.get_forecast_summary()</cite> for a dataframe-based container of prior and posterior
variances</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.posterior_parameter">
<em class="property">property </em><code class="sig-name descname">posterior_parameter</code><a class="headerlink" href="#pyemu.sc.Schur.posterior_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>posterior parameter covariance matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the posterior parameter covariance matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sc</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Schur</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jcb&quot;</span><span class="p">)</span>
<span class="n">post_cov</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">posterior_parameter</span>
<span class="n">post_cov</span><span class="o">.</span><span class="n">to_ascii</span><span class="p">(</span><span class="s2">&quot;post.cov&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.sc.Schur.posterior_prediction">
<em class="property">property </em><code class="sig-name descname">posterior_prediction</code><a class="headerlink" href="#pyemu.sc.Schur.posterior_prediction" title="Permalink to this definition">¶</a></dt>
<dd><p>posterior prediction (e.g. forecast) variance estimate(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of forecast names and FOSM-estimated posterior
variances</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><p><cite>dict</cite></p>
<dl>
<dt>Note:</dt><dd><p>sames as <cite>LinearAnalysis.posterior_forecast</cite></p>
<p>See <cite>Schur.get_forecast_summary()</cite> for a dataframe-based container of prior and posterior
variances</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyemu.ev"></span><dl class="class">
<dt id="pyemu.ev.ErrVar">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.ev.</code><code class="sig-name descname">ErrVar</code><span class="sig-paren">(</span><em class="sig-param">jco</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar" title="Permalink to this definition">¶</a></dt>
<dd><p>FOSM-based error variance analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>jco</strong> (<em>varies</em><em>, </em><em>optional</em>) – something that can be cast or loaded into a <cite>pyemu.Jco</cite>.  Can be a
str for a filename or <cite>pyemu.Matrix</cite>/<cite>pyemu.Jco</cite> object.</p></li>
<li><p><strong>pst</strong> (<em>varies</em><em>, </em><em>optional</em>) – something that can be cast into a <cite>pyemu.Pst</cite>.  Can be an <cite>str</cite> for a
filename or an existing <cite>pyemu.Pst</cite>.  If <cite>None</cite>, a pst filename is sought
with the same base name as the jco argument (if passed)</p></li>
<li><p><strong>parcov</strong> (<em>varies</em><em>, </em><em>optional</em>) – prior parameter covariance matrix.  If <cite>str</cite>, a filename is assumed and
the prior parameter covariance matrix is loaded from a file using
the file extension (“.jcb”/”.jco” for binary, “.cov”/”.mat” for PEST-style ASCII matrix,
or “.unc” for uncertainty files).  If <cite>None</cite>, the prior parameter covariance matrix is
constructed from the parameter bounds in <cite>LinearAnalysis.pst</cite>.  Can also be a <cite>pyemu.Cov</cite> instance</p></li>
<li><p><strong>obscov</strong> (<em>varies</em><em>, </em><em>optional</em>) – observation noise covariance matrix.  If <cite>str</cite>, a filename is assumed and
the noise covariance matrix is loaded from a file using
the file extension (“.jcb”/”.jco” for binary, “.cov”/”.mat” for PEST-style ASCII matrix,
or “.unc” for uncertainty files).  If <cite>None</cite>, the noise covariance matrix is
constructed from the obsevation weights in <cite>LinearAnalysis.pst</cite>.  Can also be a <cite>pyemu.Cov</cite> instance</p></li>
<li><p><strong>forecasts</strong> (<em>varies</em><em>, </em><em>optional</em>) – forecast sensitivity vectors.  If <cite>str</cite>, first an observation name is assumed (a row
in <cite>LinearAnalysis.jco</cite>).  If that is not found, a filename is assumed and predictions are
loaded from a file using the file extension.  If [<cite>str</cite>], a list of observation names is assumed.
Can also be a <cite>pyemu.Matrix</cite> instance, a <cite>numpy.ndarray</cite> or a collection.  Note if the PEST++ option
“++forecasts()” is set in the pest control file (under the <cite>pyemu.Pst.pestpp_options</cite> dictionary),
then there is no need to pass this argument (unless you want to analyze different forecasts)
of <cite>pyemu.Matrix</cite> or <cite>numpy.ndarray</cite>.</p></li>
<li><p><strong>ref_var</strong> (<em>float</em><em>, </em><em>optional</em>) – reference variance.  Default is 1.0</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>) – controls screen output.  If <cite>str</cite>, a filename is assumed and
and log file is written.</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>, optional) – defines range of upper bound - lower bound in terms of standard
deviation (sigma). For example, if sigma_range = 4, the bounds represent 4 * sigma.
Default is 4.0, representing approximately 95% confidence of implied normal distribution.
This arg is only used if constructing parcov from parameter bounds.</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>, optional) – flag to apply parameter scale and offset to parameter bounds
when calculating prior parameter covariance matrix from bounds.  This arg is onlyused if
constructing parcov from parameter bounds.Default is True.</p></li>
<li><p><strong>omitted_parameters</strong> ([<cite>str</cite>]) – list of parameters to treat as “omitted”.  Passing this argument
activates 3-term error variance analysis.</p></li>
<li><p><strong>omitted_parcov</strong> (<em>varies</em>) – an argument that can be cast to a parcov for the omitted parameters.
If None, omitted_parcov will be formed by extracting a sub-matrix from the <cite>LinearAnalsis.parcov</cite>
attribute.</p></li>
<li><p><strong>omitted_predictions</strong> (<em>varies</em>) – an argument that can be cast to a “predictions” (e.g. “forecasts”)
attribute to form prediction sensitivity vectors with respec to the omitted parameters.  If None,
these vectors will be extracted from the <cite>pyemu.LinearAnalysis.predictions</cite> attribute</p></li>
<li><p><strong>kl</strong> (<cite>bool</cite>, optional) – flag to perform Karhunen-Loeve scaling on the jacobian before error variance
calculations. If <cite>True</cite>, the <cite>pyemu.ErrVar.jco</cite> and <cite>pyemu.ErrVar.parcov</cite> are altered in place.
Default is <cite>False</cite>.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ev</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ErrVar</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">,</span><span class="n">omitted_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;wel1&quot;</span><span class="p">,</span><span class="s2">&quot;wel2&quot;</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">get_errvar_dataframe</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.ev.ErrVar.G">
<code class="sig-name descname">G</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.G" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parameter solution Matrix at a given singular value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc G at</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>parameter solution matrix  (V_1 * S_1^(_1) * U_1^T) at <cite>singular_value</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.I_minus_R">
<code class="sig-name descname">I_minus_R</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.I_minus_R" title="Permalink to this definition">¶</a></dt>
<dd><p>get I - R at a given singular value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calculate I - R at</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>identity matrix minus resolution matrix at <cite>singular_value</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.R">
<code class="sig-name descname">R</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.R" title="Permalink to this definition">¶</a></dt>
<dd><p>get resolution Matrix (V_1 * V_1^T) at a given singular value</p>
<p>Args:
singular_value (<cite>int</cite>): singular value to calculate <cite>R</cite> at</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>resolution matrix at <cite>singular_value</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.first_forecast">
<code class="sig-name descname">first_forecast</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.first_forecast" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the null space term (first term) contribution to forecast (e.g. prediction)</dt><dd><p>error variance at a given singular value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc first term at</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is used to construct the error variance dataframe</p>
<p>Just a wrapper around <cite>ErrVar.first_forecast</cite></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of (“first”,prediction_names),error variance pairs at <cite>singular_value</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.first_parameter">
<code class="sig-name descname">first_parameter</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.first_parameter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the null space term (first term) contribution to parameter error variance</dt><dd><p>at a given singular value</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc first term at</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>first term contribution to parameter error variance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.first_prediction">
<code class="sig-name descname">first_prediction</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.first_prediction" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the null space term (first term) contribution to prediction error variance</dt><dd><p>at a given singular value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc first term at</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is used to construct the error variance dataframe</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of (“first”,prediction_names),error variance pairs at <cite>singular_value</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.get_errvar_dataframe">
<code class="sig-name descname">get_errvar_dataframe</code><span class="sig-paren">(</span><em class="sig-param">singular_values=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.get_errvar_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>primary entry point for error variance analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_values</strong> ([<cite>int</cite>], optional) – a list singular values to test. If <cite>None</cite>,
defaults to <cite>range(0,min(nnz_obs,nadj_par) + 1)</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a multi-indexed pandas dataframe summarizing each of the
error variance terms for each nominated forecast. Rows are the singluar values
tested, columns are a multi-index of forecast name and error variance term number
(e.g. 1,2 or (optionally) 3).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ev</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ErrVar</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">,</span><span class="n">omitted_parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;wel1&quot;</span><span class="p">,</span><span class="s2">&quot;wel2&quot;</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">get_errvar_dataframe</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.get_identifiability_dataframe">
<code class="sig-name descname">get_identifiability_dataframe</code><span class="sig-paren">(</span><em class="sig-param">singular_value=None</em>, <em class="sig-param">precondition=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.get_identifiability_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>primary entry point for identifiability analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>singular_value</strong> (<cite>int</cite>) – the singular spectrum truncation point. Defaults
to minimum of non-zero-weighted observations and adjustable parameters</p></li>
<li><p><strong>precondition</strong> (<cite>bool</cite>) – flag to use the preconditioned hessian with the prior
parameter covariance matrix (xtqt + sigma_theta^-1).  This should be used
KL scaling. Default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pandas dataframe of the right solution-space singular
vectors and identifiability (identifiabiity is in the column labeled “ident”)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ev</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ErrVar</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">get_identifiability_dataframe</span><span class="p">(</span><span class="n">singular_value</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">ident</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.get_null_proj">
<code class="sig-name descname">get_null_proj</code><span class="sig-paren">(</span><em class="sig-param">maxsing=None</em>, <em class="sig-param">eigthresh=1e-06</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.get_null_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>get a null-space projection matrix of XTQX</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maxsing</strong> (<cite>int</cite>, optional) – number of singular components
to use (the truncation point).  If None, <cite>pyemu.Matrx.get_maxsing()
is used to determine the truncation point with `eigthresh</cite>. Default
is None</p></li>
<li><p><strong>eigthresh</strong> (<cite>float</cite>, optional) – the ratio of smallest to largest singular
value to keep in the range (solution) space of XtQX.  Not used if
<cite>maxsing</cite> is not <cite>None</cite>.  Default is 1.0e-6</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>used for null-space monte carlo operations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><cite>pyemu.Matrix</cite> the null-space projection matrix (V2V2^T)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.omitted_jco">
<em class="property">property </em><code class="sig-name descname">omitted_jco</code><a class="headerlink" href="#pyemu.ev.ErrVar.omitted_jco" title="Permalink to this definition">¶</a></dt>
<dd><p>the omitted-parameters jacobian matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the jacobian matrix instance of non-zero-weighted observations and
omitted parameters</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Jco</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.omitted_parcov">
<em class="property">property </em><code class="sig-name descname">omitted_parcov</code><a class="headerlink" href="#pyemu.ev.ErrVar.omitted_parcov" title="Permalink to this definition">¶</a></dt>
<dd><p>the prior omitted-parameter covariance matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the prior parameter covariance matrix of the
omitted parameters</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.omitted_predictions">
<em class="property">property </em><code class="sig-name descname">omitted_predictions</code><a class="headerlink" href="#pyemu.ev.ErrVar.omitted_predictions" title="Permalink to this definition">¶</a></dt>
<dd><p>omitted prediction sensitivity vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a matrix of prediction sensitivity vectors (column wise) to
omitted parameters</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.second_forecast">
<code class="sig-name descname">second_forecast</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.second_forecast" title="Permalink to this definition">¶</a></dt>
<dd><p>get the solution space contribution to forecast (e.g. “prediction”) error variance
at a given singular value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc second term at</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is used to construct error variance dataframe</p>
<p>Just a thin wrapper around <cite>ErrVar.second_prediction</cite></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of (“second”,prediction_names), error variance
arising from the solution space contribution (y^t * G * obscov * G^T * y)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.second_parameter">
<code class="sig-name descname">second_parameter</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.second_parameter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the solution space contribution to parameter error variance</dt><dd><p>at a given singular value (G * obscov * G^T)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc second term at</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the second term contribution to parameter error variance
(G * obscov * G^T)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.second_prediction">
<code class="sig-name descname">second_prediction</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.second_prediction" title="Permalink to this definition">¶</a></dt>
<dd><p>get the solution space contribution to predictive error variance
at a given singular value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc second term at</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is used to construct error variance dataframe</p>
</div>
<dl class="simple">
<dt>Returns:            <cite>dict</cite>:  dictionary of (“second”,prediction_names), error variance</dt><dd><p>arising from the solution space contribution (y^t * G * obscov * G^T * y)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.third_forecast">
<code class="sig-name descname">third_forecast</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.third_forecast" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the omitted parameter contribution to forecast (<cite>prediction</cite>) error variance</dt><dd><p>at a given singular value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc third term at</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>used to construct error variance dataframe
just a thin wrapper around <cite>ErrVar.third_prediction()</cite></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dictionary of (“third”,prediction_names),error variance</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.third_parameter">
<code class="sig-name descname">third_parameter</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.third_parameter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the omitted parameter contribution to parameter error variance</dt><dd><p>at a given singular value</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc third term at</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the third term contribution to parameter error variance
calculated at <cite>singular_value</cite> (G * omitted_jco * Sigma_(omitted_pars) *
omitted_jco^T * G^T).  Returns 0.0 if third term calculations are not
being used.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.third_prediction">
<code class="sig-name descname">third_prediction</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.third_prediction" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the omitted parameter contribution to prediction error variance</dt><dd><p>at a given singular value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to calc third term at</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>used to construct error variance dataframe</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dictionary of (“third”,prediction_names),error variance</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.ev.ErrVar.variance_at">
<code class="sig-name descname">variance_at</code><span class="sig-paren">(</span><em class="sig-param">singular_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.ev.ErrVar.variance_at" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>get the error variance of all three error variance terms at a</dt><dd><p>given singluar value</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>singular_value</strong> (<cite>int</cite>) – singular value to test</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary of (err var term,prediction_name), variance pairs</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>dict</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyemu.en"></span><dl class="class">
<dt id="pyemu.en.Ensemble">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.en.</code><code class="sig-name descname">Ensemble</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">df</em>, <em class="sig-param">istransformed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>based class for handling ensembles of numeric values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>df</strong> (<cite>pandas.DataFrame</cite>) – a pandas dataframe.  Columns
should be parameter/observation names.  Index is
treated as realization names</p></li>
<li><p><strong>istransformed</strong> (<cite>bool</cite>) – flag to indicate parameter values
are in log space.  Not used for <cite>ObservationEnsemble</cite></p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.en.Ensemble.as_pyemu_matrix">
<code class="sig-name descname">as_pyemu_matrix</code><span class="sig-paren">(</span><em class="sig-param">typ=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.as_pyemu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>get a <cite>pyemu.Matrix</cite> instance of <cite>Ensemble</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>typ</strong> (<cite>pyemu.Matrix</cite> or <cite>pyemu.Cov</cite>) – the type of matrix to return.
Default is <cite>pyemu.Matrix</cite></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a matrix instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Matrix</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">oe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">oe</span><span class="o">.</span><span class="n">add_base</span><span class="p">()</span>
<span class="n">oe_dev</span> <span class="o">=</span> <span class="n">oe</span><span class="o">.</span><span class="n">get_deviations</span><span class="p">(</span><span class="n">center_on</span><span class="o">=</span><span class="s2">&quot;base&quot;</span><span class="p">)</span>
<span class="n">oe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;obs_base_devs.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.back_transform">
<code class="sig-name descname">back_transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.back_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>back transform parameters with respect to <cite>partrans</cite> value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>operates in place (None is returned).</p>
<p>Parameter transform is only related to log_{10} and does not
include the effects of <cite>scale</cite> and/or <cite>offset</cite></p>
<p><cite>Ensemble.back_transform() is only provided for inhertance purposes.
It only changes the `Ensemble._transformed</cite> flag</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>get a copy of <cite>Ensemble</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>copy of this <cite>Ensemble</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>Ensemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>copies both <cite>Ensemble.pst</cite> and <cite>Ensemble._df</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.covariance_matrix">
<code class="sig-name descname">covariance_matrix</code><span class="sig-paren">(</span><em class="sig-param">localizer=None</em>, <em class="sig-param">center_on=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>get a empirical covariance matrix implied by the
correlations between realizations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>localizer</strong> (<cite>pyemu.Matrix</cite>, optional) – a matrix to localize covariates
in the resulting covariance matrix.  Default is None</p></li>
<li><p><strong>center_on</strong> (<cite>str</cite>, optional) – a realization name to use as the centering
point in ensemble space.  If <cite>None</cite>, the mean vector is
treated as the centering point.  Default is None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the empirical (and optionally localized) covariance matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.dropna">
<code class="sig-name descname">dropna</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.dropna" title="Permalink to this definition">¶</a></dt>
<dd><p>override of <cite>pandas.DataFrame.dropna()</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>[</strong><strong>object</strong><strong>]</strong> (<em>*args</em>) – positional arguments to pass to
<cite>pandas.DataFrame.dropna()</cite>.</p></li>
<li><p><strong>(</strong><strong>{str</strong> (<em>**kwargs</em>) – <cite>object</cite>}): keyword arguments to pass
to <cite>pandas.DataFrame.dropna()</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.from_binary">
<em class="property">classmethod </em><code class="sig-name descname">from_binary</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.from_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>create an <cite>Ensemble</cite> from a PEST-style binary file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>) – filename containing binary ensemble</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the ensembled loaded from the binary file</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Ensemble</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">oe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_binary</span><span class="p">(</span><span class="s2">&quot;obs.jcb&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.from_csv">
<em class="property">classmethod </em><code class="sig-name descname">from_csv</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">filename</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.from_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>create an <cite>Ensemble</cite> from a CSV file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>) – filename containing CSV ensemble</p></li>
<li><p><strong>(</strong><strong>[</strong><strong>object</strong><strong>]</strong> (<em>*args</em>) – positional arguments to pass to
<cite>pandas.read_csv()</cite>.</p></li>
<li><p><strong>(</strong><strong>{str</strong> (<em>**kwargs</em>) – <cite>object</cite>}): keyword arguments to pass
to <cite>pandas.read_csv()</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>Ensemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>uses <cite>pandas.read_csv()</cite> to load numeric values from
CSV file</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">oe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_csv</span><span class="p">(</span><span class="s2">&quot;obs.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.get_deviations">
<code class="sig-name descname">get_deviations</code><span class="sig-paren">(</span><em class="sig-param">center_on=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.get_deviations" title="Permalink to this definition">¶</a></dt>
<dd><p>get the deviations of the realizations around a certain
point in ensemble space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center_on</strong> (<cite>str</cite>, optional) – a realization name to use as the centering
point in ensemble space.  If <cite>None</cite>, the mean vector is
treated as the centering point.  Default is None</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an ensemble of deviations around the centering point</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Ensemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>deviations are the Euclidean distances from the <cite>center_on</cite> value to
realized values for each column</p>
<p><cite>center_on=None</cite> yields the classic ensemble smoother/ensemble Kalman
filter deviations</p>
<p>Deviations respect log-transformation status.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.istransformed">
<em class="property">property </em><code class="sig-name descname">istransformed</code><a class="headerlink" href="#pyemu.en.Ensemble.istransformed" title="Permalink to this definition">¶</a></dt>
<dd><p>the parameter transformation status</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>flag to indicate whether or not the <cite>ParameterEnsemble</cite> is
transformed with respect to log_{10}.  Not used for (and has no effect
on) <cite>ObservationEnsemble</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>bool</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>parameter transformation status is only related to log_{10} and does not
include the effects of <cite>scale</cite> and/or <cite>offset</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">bins=10</em>, <em class="sig-param">facecolor='0.5'</em>, <em class="sig-param">plot_cols=None</em>, <em class="sig-param">filename='ensemble.pdf'</em>, <em class="sig-param">func_dict=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>plot ensemble histograms to multipage pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bins</strong> (<cite>int</cite>) – number of bins for the histograms</p></li>
<li><p><strong>facecolor</strong> (<cite>str</cite>) – matplotlib color (e.g. <cite>r</cite>,`g`, etc)</p></li>
<li><p><strong>plot_cols</strong> ([<cite>str</cite>]) – list of subset of ensemble columns to plot.
If None, all are plotted. Default is None</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>) – multipage pdf filename. Default is “ensemble.pdf”</p></li>
<li><p><strong>func_dict</strong> (<cite>dict</cite>) – a dict of functions to apply to specific
columns. For example: {“par1”: np.log10}</p></li>
<li><p><strong>**kwargs</strong> (<cite>dict</cite>) – addkeyword args to pass to <cite>pyemu.plot_utils.ensemble_helper()</cite></p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">transform</span><span class="p">()</span> <span class="c1"># plot log space (if needed)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.en.Ensemble.pst">
<code class="sig-name descname">pst</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.en.Ensemble.pst" title="Permalink to this definition">¶</a></dt>
<dd><p>control file instance</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><cite>pyemu.Pst</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.reseed">
<em class="property">static </em><code class="sig-name descname">reseed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.reseed" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the <cite>numpy.random.seed</cite></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>reseeds using the pyemu.en.SEED global variable</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.to_binary">
<code class="sig-name descname">to_binary</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.to_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>write <cite>Ensemble</cite> to a PEST-style binary file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – file to write</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">oe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">oe</span><span class="o">.</span><span class="n">to_binary</span><span class="p">(</span><span class="s2">&quot;obs.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>back transforms <cite>ParameterEnsemble</cite> before writing so that
values are in arithmatic space</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.to_csv">
<code class="sig-name descname">to_csv</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>write <cite>Ensemble</cite> to a CSV file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – file to write</p></li>
<li><p><strong>(</strong><strong>[</strong><strong>object</strong><strong>]</strong> (<em>*args</em>) – positional arguments to pass to
<cite>pandas.DataFrame.to_csv()</cite>.</p></li>
<li><p><strong>(</strong><strong>{str</strong> (<em>**kwargs</em>) – <cite>object</cite>}): keyword arguments to pass
to <cite>pandas.DataFrame.to_csv()</cite>.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">oe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">oe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;obs.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>back transforms <cite>ParameterEnsemble</cite> before writing so that
values are in arithmatic space</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.Ensemble.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.Ensemble.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>transform parameters with respect to <cite>partrans</cite> value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>operates in place (None is returned).</p>
<p>Parameter transform is only related to log_{10} and does not
include the effects of <cite>scale</cite> and/or <cite>offset</cite></p>
<p><cite>Ensemble.transform() is only provided for inhertance purposes.
It only changes the `Ensemble._transformed</cite> flag</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyemu.en.ParameterEnsemble">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.en.</code><code class="sig-name descname">ParameterEnsemble</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">df</em>, <em class="sig-param">istransformed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter ensembles in the PEST(++) realm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>df</strong> (<cite>pandas.DataFrame</cite>) – a pandas dataframe.  Columns
should be parameter names.  Index is
treated as realization names</p></li>
<li><p><strong>istransformed</strong> (<cite>bool</cite>) – flag to indicate parameter values
are in log space (if <cite>partrans</cite> is “log” in <cite>pst</cite>)</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.add_base">
<code class="sig-name descname">add_base</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.add_base" title="Permalink to this definition">¶</a></dt>
<dd><p>add the control file <cite>obsval</cite> values as a realization</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>replaces the last realization with the current <cite>ParameterEnsemble.pst.parameter_data.parval1</cite> values
as a new realization named “base”</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.adj_names">
<em class="property">property </em><code class="sig-name descname">adj_names</code><a class="headerlink" href="#pyemu.en.ParameterEnsemble.adj_names" title="Permalink to this definition">¶</a></dt>
<dd><p>the names of adjustable parameters in <cite>ParameterEnsemble</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>adjustable parameter names</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>str</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.back_transform">
<code class="sig-name descname">back_transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.back_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>back transform parameters with respect to <cite>partrans</cite> value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>operates in place (None is returned).</p>
<p>Parameter transform is only related to log_{10} and does not
include the effects of <cite>scale</cite> and/or <cite>offset</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.enforce">
<code class="sig-name descname">enforce</code><span class="sig-paren">(</span><em class="sig-param">how='reset'</em>, <em class="sig-param">bound_tol=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.enforce" title="Permalink to this definition">¶</a></dt>
<dd><p>entry point for bounds enforcement.  This gets called for the
draw method(s), so users shouldn’t need to call this</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>enforce_bounds</strong> (<cite>str</cite>) – can be ‘reset’ to reset offending values or ‘drop’ to drop
offending realizations</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">()</span>
<span class="n">pe</span><span class="o">.</span><span class="n">enforce</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s2">&quot;scale)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;par.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.fixed_indexer">
<em class="property">property </em><code class="sig-name descname">fixed_indexer</code><a class="headerlink" href="#pyemu.en.ParameterEnsemble.fixed_indexer" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean indexer for non-adjustable parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>boolean array indicating which parameters have
<cite>partrans</cite> equal to “log” or “fixed”</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>numpy.ndarray(bool)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.from_gaussian_draw">
<em class="property">classmethod </em><code class="sig-name descname">from_gaussian_draw</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">cov=None</em>, <em class="sig-param">num_reals=100</em>, <em class="sig-param">by_groups=True</em>, <em class="sig-param">fill=True</em>, <em class="sig-param">factor='eigen'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.from_gaussian_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a <cite>ParameterEnsemble</cite> from a (multivariate) (log) gaussian
distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance.</p></li>
<li><p><strong>cov</strong> (<cite>pyemu.Cov</cite>) – a covariance matrix describing the second
moment of the gaussian distribution.  If None, <cite>cov</cite> is
generated from the bounds of the adjustable parameters in <cite>pst</cite>.
the (log) width of the bounds is assumed to represent a multiple of
the parameter standard deviation (this is the <cite>sigma_range</cite> argument
that can be passed to <cite>pyemu.Cov.from_parameter_data</cite>).</p></li>
<li><p><strong>num_reals</strong> (<cite>int</cite>) – number of stochastic realizations to generate.  Default
is 100</p></li>
<li><p><strong>by_groups</strong> (<cite>bool</cite>) – flag to generate realzations be parameter group.  This
assumes no correlation (covariates) between parameter groups.  For large
numbers of parameters, this help prevent memories but is slower.</p></li>
<li><p><strong>fill</strong> (<cite>bool</cite>) – flag to fill in fixed and/or tied parameters with control file
values.  Default is True.</p></li>
<li><p><strong>factor</strong> (<cite>str</cite>) – how to factorize <cite>cov</cite> to form the projectin matrix.  Can
be “eigen” or “svd”. The “eigen” option is default and is faster.  But
for (nearly) singular cov matrices (such as those generated empirically
from ensembles), “svd” is the only way.  Ignored for diagonal <cite>cov</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the parameter ensemble realized from the gaussian
distribution</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>ParameterEnsemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only parameters named in <cite>cov</cite> are sampled. Missing parameters are assigned values of
<cite>pst.parameter_data.parval1</cite> along the corresponding columns of <cite>ParameterEnsemble</cite>
according to the value of <cite>fill</cite>.</p>
<p>The default <cite>cov</cite> is generated from <cite>pyemu.Cov.from_observation_data</cite>, which assumes
parameter bounds in <cite>ParameterEnsemble.pst</cite> represent some multiple of parameter
standard deviations.  Additionally, the default Cov only includes adjustable
parameters (<cite>partrans</cite> not “tied” or “fixed”).</p>
<p>“tied” parameters are not sampled.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="c1"># the easiest way - just relying on weights in pst</span>
<span class="n">oe1</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>

<span class="c1"># generate the cov explicitly with a sigma_range</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_parameter_data</span><span class="p">(</span><span class="n">pst</span><span class="p">,</span><span class="n">sigma_range</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">oe2</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">,</span><span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.from_mixed_draws">
<em class="property">classmethod </em><code class="sig-name descname">from_mixed_draws</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">how_dict</em>, <em class="sig-param">default='gaussian'</em>, <em class="sig-param">num_reals=100</em>, <em class="sig-param">cov=None</em>, <em class="sig-param">sigma_range=6</em>, <em class="sig-param">enforce_bounds=True</em>, <em class="sig-param">partial=False</em>, <em class="sig-param">fill=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.from_mixed_draws" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a <cite>ParameterEnsemble</cite> using a mixture of
distributions.  Available distributions include (log) “uniform”, (log) “triangular”,
and (log) “gaussian”. log transformation is respected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file</p></li>
<li><p><strong>how_dict</strong> (<cite>dict</cite>) – a dictionary of parameter name keys and
“how” values, where “how” can be “uniform”,”triangular”, or “gaussian”.</p></li>
<li><p><strong>default</strong> (<cite>str</cite>) – the default distribution to use for parameter not listed
in how_dict.  Default is “gaussian”.</p></li>
<li><p><strong>num_reals</strong> (<cite>int</cite>) – number of realizations to draw.  Default is 100.</p></li>
<li><p><strong>cov</strong> (<cite>pyemu.Cov</cite>) – an optional Cov instance to use for drawing from gaussian distribution.
If None, and “gaussian” is listed in <cite>how_dict</cite> (and/or <cite>default</cite>), then a diagonal
covariance matrix is constructed from the parameter bounds in <cite>pst</cite> (with <cite>sigma_range</cite>).
Default is None.</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>) – the number of standard deviations implied by the parameter bounds in the pst.
Only used if “gaussian” is in <cite>how_dict</cite> (and/or <cite>default</cite>) and <cite>cov</cite> is None.  Default is 6.</p></li>
<li><p><strong>enforce_bounds</strong> (<cite>bool</cite>) – flag to enforce parameter bounds in resulting <cite>ParameterEnsemble</cite>. Only
matters if “gaussian” is in values of <cite>how_dict</cite>.  Default is True.</p></li>
<li><p><strong>partial</strong> (<cite>bool</cite>) – flag to allow a partial ensemble (not all pars included).  If True, parameters
not name in <cite>how_dict</cite> will be sampled using the distribution named as <cite>default</cite>.
Default is <cite>False</cite>.</p></li>
<li><p><strong>fill</strong> (<cite>bool</cite>) – flag to fill in fixed and/or tied parameters with control file
values.  Default is True.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.from_parfiles">
<em class="property">classmethod </em><code class="sig-name descname">from_parfiles</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">parfile_names</em>, <em class="sig-param">real_names=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.from_parfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>create a parameter ensemble from PEST-style parameter value files.
Accepts parfiles with less than the parameters in the control
(get NaNs in the ensemble) or extra parameters in the
parfiles (get dropped)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – control file instance</p></li>
<li><p><strong>parfile_names</strong> (<cite>[str</cite>]) – par file names</p></li>
<li><p><strong>real_names</strong> (<cite>str</cite>) – optional list of realization names.
If None, a single integer counter is used</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>parameter ensemble loaded from par files</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>ParameterEnsemble</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.from_triangular_draw">
<em class="property">classmethod </em><code class="sig-name descname">from_triangular_draw</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">num_reals=100</em>, <em class="sig-param">fill=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.from_triangular_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a <cite>ParameterEnsemble</cite> from a (multivariate) (log) triangular distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>num_reals</strong> (<cite>int</cite>, optional) – number of realizations to generate.  Default is 100</p></li>
<li><p><strong>fill</strong> (<cite>bool</cite>) – flag to fill in fixed and/or tied parameters with control file
values.  Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a parameter ensemble drawn from the multivariate (log) triangular
distribution defined by the parameter upper and lower bounds and initial parameter
values in <cite>pst</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>ParameterEnsemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>respects transformation status in <cite>pst</cite>: fixed and tied parameters are not realized,
log-transformed parameters are drawn in log space.  The returned <cite>ParameterEnsemble</cite>
is back transformed (not in log space)</p>
<p>uses numpy.random.triangular</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_triangular_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;my_tri_pe.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.from_uniform_draw">
<em class="property">classmethod </em><code class="sig-name descname">from_uniform_draw</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">num_reals</em>, <em class="sig-param">fill=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.from_uniform_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a <cite>ParameterEnsemble</cite> from a (multivariate) (log) uniform
distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>num_reals</strong> (<cite>int</cite>, optional) – number of realizations to generate.  Default is 100</p></li>
<li><p><strong>fill</strong> (<cite>bool</cite>) – flag to fill in fixed and/or tied parameters with control file
values.  Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a parameter ensemble drawn from the multivariate (log) uniform
distribution defined by the parameter upper and lower bounds <cite>pst</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>ParameterEnsemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>respects transformation status in <cite>pst</cite>: fixed and tied parameters are not realized,
log-transformed parameters are drawn in log space.  The returned <cite>ParameterEnsemble</cite>
is back transformed (not in log space)</p>
<p>uses numpy.random.uniform</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_uniform_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">pe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;my_uni_pe.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.lbnd">
<em class="property">property </em><code class="sig-name descname">lbnd</code><a class="headerlink" href="#pyemu.en.ParameterEnsemble.lbnd" title="Permalink to this definition">¶</a></dt>
<dd><p>the lower bound vector while respecting current log transform status</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(log-transformed) lower parameter bounds listed in
<cite>ParameterEnsemble.pst.parameter_data.parlbnd</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.Series</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.log_indexer">
<em class="property">property </em><code class="sig-name descname">log_indexer</code><a class="headerlink" href="#pyemu.en.ParameterEnsemble.log_indexer" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean indexer for log transform</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>boolean array indicating which parameters are log
transformed</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>numpy.ndarray(bool)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.project">
<code class="sig-name descname">project</code><span class="sig-paren">(</span><em class="sig-param">projection_matrix</em>, <em class="sig-param">center_on=None</em>, <em class="sig-param">log=None</em>, <em class="sig-param">enforce_bounds='reset'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.project" title="Permalink to this definition">¶</a></dt>
<dd><p>project the ensemble using the null-space Monte Carlo method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>projection_matrix</strong> (<cite>pyemu.Matrix</cite>) – null-space projection operator.</p></li>
<li><p><strong>center_on</strong> (<cite>str</cite>) – the name of the realization to use as the centering
point for the null-space differening operation.  If <cite>center_on</cite> is <cite>None</cite>,
the <cite>ParameterEnsemble</cite> mean vector is used.  Default is <cite>None</cite></p></li>
<li><p><strong>log</strong> (<cite>pyemu.Logger</cite>, optional) – for logging progress</p></li>
<li><p><strong>enforce_bounds</strong> (<cite>str</cite>) – parameter bound enforcement option to pass to
<cite>ParameterEnsemble.enforce()</cite>.  Valid options are <cite>reset</cite>, <cite>drop</cite>,
<cite>scale</cite> or <cite>None</cite>.  Default is <cite>reset</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>untransformed, null-space projected ensemble.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>ParameterEnsemble</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ev</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ErrVar</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s2">&quot;my.jco&quot;</span><span class="p">)</span> <span class="c1">#assumes my.pst exists</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">ev</span><span class="o">.</span><span class="n">pst</span><span class="p">)</span>
<span class="n">pe_proj</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">ev</span><span class="o">.</span><span class="n">get_null_proj</span><span class="p">(</span><span class="n">maxsing</span><span class="o">=</span><span class="mi">25</span><span class="p">))</span>
<span class="n">pe_proj</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;proj_par.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ParameterEnsemble.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>transform parameters with respect to <cite>partrans</cite> value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>operates in place (None is returned).</p>
<p>Parameter transform is only related to log_{10} and does not
include the effects of <cite>scale</cite> and/or <cite>offset</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ParameterEnsemble.ubnd">
<em class="property">property </em><code class="sig-name descname">ubnd</code><a class="headerlink" href="#pyemu.en.ParameterEnsemble.ubnd" title="Permalink to this definition">¶</a></dt>
<dd><p>the upper bound vector while respecting current log transform status</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(log-transformed) upper parameter bounds listed in
<cite>ParameterEnsemble.pst.parameter_data.parubnd</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.Series</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyemu.en.ObservationEnsemble">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.en.</code><code class="sig-name descname">ObservationEnsemble</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">df</em>, <em class="sig-param">istransformed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ObservationEnsemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Observation noise ensemble in the PEST(++) realm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>df</strong> (<cite>pandas.DataFrame</cite>) – a pandas dataframe.  Columns
should be observation names.  Index is
treated as realization names</p></li>
<li><p><strong>istransformed</strong> (<cite>bool</cite>) – flag to indicate parameter values
are in log space.  Not used for <cite>ObservationEnsemble</cite></p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">oe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.en.ObservationEnsemble.add_base">
<code class="sig-name descname">add_base</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ObservationEnsemble.add_base" title="Permalink to this definition">¶</a></dt>
<dd><p>add the control file <cite>obsval</cite> values as a realization</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>replaces the last realization with the current <cite>ObservationEnsemble.pst.observation_data.obsval</cite> values</dt><dd><p>as a new realization named “base”</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ObservationEnsemble.from_gaussian_draw">
<em class="property">classmethod </em><code class="sig-name descname">from_gaussian_draw</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">cov=None</em>, <em class="sig-param">num_reals=100</em>, <em class="sig-param">by_groups=True</em>, <em class="sig-param">fill=False</em>, <em class="sig-param">factor='eigen'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.en.ObservationEnsemble.from_gaussian_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>generate an <cite>ObservationEnsemble</cite> from a (multivariate) gaussian
distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance.</p></li>
<li><p><strong>cov</strong> (<cite>pyemu.Cov</cite>) – a covariance matrix describing the second
moment of the gaussian distribution.  If None, <cite>cov</cite> is
generated from the non-zero-weighted observation weights in <cite>pst</cite>.
Only observations listed in <cite>cov</cite> are sampled.  Other observations are
assigned the <cite>obsval</cite> value from <cite>pst</cite>.</p></li>
<li><p><strong>num_reals</strong> (<cite>int</cite>) – number of stochastic realizations to generate.  Default
is 100</p></li>
<li><p><strong>by_groups</strong> (<cite>bool</cite>) – flag to generate realzations be observation group.  This
assumes no correlation (covariates) between observation groups.</p></li>
<li><p><strong>fill</strong> (<cite>bool</cite>) – flag to fill in zero-weighted observations with control file
values.  Default is False.</p></li>
<li><p><strong>factor</strong> (<cite>str</cite>) – how to factorize <cite>cov</cite> to form the projectin matrix.  Can
be “eigen” or “svd”. The “eigen” option is default and is faster.  But
for (nearly) singular cov matrices (such as those generated empirically
from ensembles), “svd” is the only way.  Ignored for diagonal <cite>cov</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the realized <cite>ObservationEnsemble</cite> instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>ObservationEnsemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only observations named in <cite>cov</cite> are sampled. Additional, <cite>cov</cite> is processed prior
to sampling to only include non-zero-weighted observations depending on the value of <cite>fill</cite>.
So users must take care to make sure observations have been assigned non-zero weights even if <cite>cov</cite>
is being passed</p>
<p>The default <cite>cov</cite> is generated from <cite>pyemu.Cov.from_observation_data</cite>, which assumes
observation noise standard deviations are the inverse of the weights listed in <cite>pst</cite></p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="c1"># the easiest way - just relying on weights in pst</span>
<span class="n">oe1</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>

<span class="c1"># generate the cov explicitly</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_observation_data</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">oe2</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">,</span><span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>

<span class="c1"># give all but one observation zero weight.  This will</span>
<span class="c1"># result in an oe with only one randomly sampled observation noise</span>
<span class="c1"># vector since the cov is processed to remove any zero-weighted</span>
<span class="c1"># observations before sampling</span>
<span class="n">pst</span><span class="o">.</span><span class="n">observation_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pst</span><span class="o">.</span><span class="n">nnz_obs_names</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="s2">&quot;weight] = 0.0</span>
<span class="n">oe3</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ObservationEnsemble</span><span class="o">.</span><span class="n">from_gaussian_draw</span><span class="p">(</span><span class="n">pst</span><span class="p">,</span><span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ObservationEnsemble.nonzero">
<em class="property">property </em><code class="sig-name descname">nonzero</code><a class="headerlink" href="#pyemu.en.ObservationEnsemble.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>get a new <cite>ObservationEnsemble</cite> of just non-zero weighted observations</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>non-zero weighted observation ensemble.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>ObservationEnsemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <cite>pst</cite> attribute of the returned <cite>ObservationEnsemble</cite> also only includes
non-zero weighted observations (and is therefore not valid for running
with PEST or PEST++)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.en.ObservationEnsemble.phi_vector">
<em class="property">property </em><code class="sig-name descname">phi_vector</code><a class="headerlink" href="#pyemu.en.ObservationEnsemble.phi_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>vector of L2 norm (phi) for the realizations (rows) of <cite>Ensemble</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>series of realization name (<cite>Ensemble.index</cite>) and phi values</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pandas.Series</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ObservationEnsemble.pst.weights can be updated prior to calling
this method to evaluate new weighting strategies</p>
</div>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyemu.prototypes">
<code class="sig-prename descclassname">pyemu.</code><code class="sig-name descname">prototypes</code><a class="headerlink" href="#pyemu.prototypes" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyemu.prototypes" title="pyemu.prototypes"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyemu.prototypes</span></code></a></p>
</dd></dl>

<span class="target" id="module-pyemu.utils.gw_utils"></span><p>MODFLOW support utilities</p>
<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_gage_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_gage_obs</code><span class="sig-paren">(</span><em class="sig-param">return_obs_file=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_gage_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the modflow gage obs post-processor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>return_obs_file</strong> (<cite>bool</cite>) – flag to return the processed
observation file.  Default is <cite>False</cite>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the companion function of <cite>gw_utils.setup_gage_obs()</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_hds_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_hds_obs</code><span class="sig-paren">(</span><em class="sig-param">hds_file</em>, <em class="sig-param">inact_abs_val=1e+20</em>, <em class="sig-param">precision='single'</em>, <em class="sig-param">text='head'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_hds_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>process a modflow head save file.  A companion function to
<cite>gw_utils.setup_hds_obs()</cite> that is called during the forward run process</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hds_file</strong> (<cite>str</cite>) – a modflow head save filename. if hds_file ends with ‘ucn’,
then the file is treated as a UcnFile type.</p></li>
<li><p><strong>inact_abs_val</strong> (<cite>float</cite>, optional) – the value that marks the mininum and maximum
active value.  values in the headsave file greater than <cite>inact_abs_val</cite> or less
than -<cite>inact_abs_val</cite> are reset to <cite>inact_abs_val</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with extracted simulated values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the companion function to <cite>gw_utils.setup_hds_obs()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_hds_timeseries">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_hds_timeseries</code><span class="sig-paren">(</span><em class="sig-param">config_file=None</em>, <em class="sig-param">postprocess_inact=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_hds_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>process a modflow binary file using a previously written
configuration file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>config_file</strong> (<cite>str</cite>, optional) – configuration file written by <cite>pyemu.gw_utils.setup_hds_timeseries</cite>.
If <cite>None</cite>, looks for <cite>hds_timeseries.config</cite></p></li>
<li><p><strong>postprocess_inact</strong> (<cite>float</cite>, optional) – Inactive value in heads/ucn file e.g. mt.btn.cinit.  If <cite>None</cite>, no
inactive value processing happens.  Default is <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this is the companion function of <cite>gw_utils.setup_hds_timeseries()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_hfb_pars">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_hfb_pars</code><span class="sig-paren">(</span><em class="sig-param">par_file='hfb6_pars.csv'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_hfb_pars" title="Permalink to this definition">¶</a></dt>
<dd><p>a function to apply HFB multiplier parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>par_file</strong> (<cite>str</cite>) – the HFB parameter info file.
Default is <cite>hfb_pars.csv</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the companion function to
<cite>gw_utils.write_hfb_zone_multipliers_template()</cite></p>
<p>This is to account for the horrible HFB6 format that differs from other
BCs making this a special case</p>
<p>Requires “hfb_pars.csv”</p>
<p>Should be added to the forward_run.py script</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_mflist_budget_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_mflist_budget_obs</code><span class="sig-paren">(</span><em class="sig-param">list_filename</em>, <em class="sig-param">flx_filename='flux.dat'</em>, <em class="sig-param">vol_filename='vol.dat'</em>, <em class="sig-param">start_datetime='1-1-1970'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_mflist_budget_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>process a MODFLOW list file to extract flux and volume water budget entries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_filename</strong> (<cite>str</cite>) – path and name of the existing modflow list file</p></li>
<li><p><strong>flx_filename</strong> (<cite>str</cite>, optional) – output filename that will contain the budget flux
observations. Default is “flux.dat”</p></li>
<li><p><strong>vol_filename</strong> (<cite>str</cite>, optional) – output filename that will contain the budget volume
observations.  Default is “vol.dat”</p></li>
<li><p><strong>start_datetime</strong> (<cite>str</cite>, optional) – a string that can be parsed into a pandas.TimeStamp.
This is used to give budget observations meaningful names.  Default is “1-1-1970”.</p></li>
<li><p><strong>prefix</strong> (<cite>str</cite>, optional) – a prefix to add to the water budget observations.  Useful if
processing more than one list file as part of the forward run process. Default is ‘’.</p></li>
<li><p><strong>save_setup_file</strong> – a flag to save _setup_&lt;list_filename&gt;.csv file that contains useful
control file information</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_mtlist_budget_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_mtlist_budget_obs</code><span class="sig-paren">(</span><em class="sig-param">list_filename</em>, <em class="sig-param">gw_filename='mtlist_gw.dat'</em>, <em class="sig-param">sw_filename='mtlist_sw.dat'</em>, <em class="sig-param">start_datetime='1-1-1970'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_mtlist_budget_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>process an MT3D-USGS list file to extract mass budget entries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_filename</strong> (<cite>str</cite>) – the path and name of an existing MT3D-USGS list file</p></li>
<li><p><strong>gw_filename</strong> (<cite>str</cite>, optional) – the name of the output file with gw mass
budget information. Default is “mtlist_gw.dat”</p></li>
<li><p><strong>sw_filename</strong> (<cite>str</cite>) – the name of the output file with sw mass budget information.
Default is “mtlist_sw.dat”</p></li>
<li><p><strong>start_datatime</strong> (<cite>str</cite>) – an str that can be cast to a pandas.TimeStamp.  Used to give
observations a meaningful name</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p><strong>pandas.DataFrame</strong>: the gw mass budget dataframe</p></li>
<li><p><strong>pandas.DataFrame</strong>: (optional) the sw mass budget dataframe.
If the SFT process is not active, this returned value is <cite>None</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this is the companion function of <cite>gw_utils.setup_mtlist_budget_obs()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_sfr_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_sfr_obs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_sfr_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the sfr observation process</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the companion function of <cite>gw_utils.setup_sfr_obs()</cite>.</p>
<p>requires <cite>sfr_obs.config</cite>.</p>
<p>Writes <cite>sfr_out_file`+”.processed”, where `sfr_out_file</cite> is defined in “sfr_obs.config”</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe of aggregrated sfr segment aquifer and outflow</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_sfr_parameters">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_sfr_parameters</code><span class="sig-paren">(</span><em class="sig-param">seg_pars=True</em>, <em class="sig-param">reach_pars=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_sfr_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>thin wrapper around <cite>gw_utils.apply_sfr_seg_parameters()</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seg_pars</strong> (<cite>bool</cite>, optional) – flag to apply segment-based parameters.
Default is True</p></li>
<li><p><strong>reach_pars</strong> (<cite>bool</cite>, optional) – flag to apply reach-based parameters.
Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the modified SFR package instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>flopy.modflow.ModflowSfr</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>expects “sfr_seg_pars.config” to exist</p>
<p>expects <cite>nam_file</cite> +”_backup_.sfr” to exist</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_sfr_reach_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_sfr_reach_obs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_sfr_reach_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the sfr reach observation process.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the companion function of <cite>gw_utils.setup_sfr_reach_obs()</cite>.</p>
<p>Requires sfr_reach_obs.config.</p>
<p>Writes &lt;sfr_out_file&gt;.processed, where &lt;sfr_out_file&gt; is defined in
“sfr_reach_obs.config”</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe of sfr aquifer and outflow ad segment,reach locations</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pd.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_sfr_seg_parameters">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_sfr_seg_parameters</code><span class="sig-paren">(</span><em class="sig-param">seg_pars=True</em>, <em class="sig-param">reach_pars=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_sfr_seg_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the SFR segement multiplier parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seg_pars</strong> (<cite>bool</cite>, optional) – flag to apply segment-based parameters.
Default is True</p></li>
<li><p><strong>reach_pars</strong> (<cite>bool</cite>, optional) – flag to apply reach-based parameters.
Default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the modified SFR package instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>flopy.modflow.ModflowSfr</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>expects “sfr_seg_pars.config” to exist</p>
<p>expects <cite>nam_file</cite> +”_backup_.sfr” to exist</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.apply_sft_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">apply_sft_obs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.apply_sft_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>process an mt3d-usgs sft ASCII output file using a previous-written
config file</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe of extracted simulated outputs</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this is the companion function to <cite>gw_utils.setup_sft_obs()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.last_kstp_from_kper">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">last_kstp_from_kper</code><span class="sig-paren">(</span><em class="sig-param">hds</em>, <em class="sig-param">kper</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.last_kstp_from_kper" title="Permalink to this definition">¶</a></dt>
<dd><p>function to find the last time step (kstp) for a
give stress period (kper) in a modflow head save file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hds</strong> (<cite>flopy.utils.HeadFile</cite>) – head save file</p></li>
<li><p><strong>kper</strong> (<cite>int</cite>) – the zero-index stress period number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the zero-based last time step during stress period
kper in the head save file</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>int</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.load_sfr_out">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">load_sfr_out</code><span class="sig-paren">(</span><em class="sig-param">sfr_out_file</em>, <em class="sig-param">selection=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.load_sfr_out" title="Permalink to this definition">¶</a></dt>
<dd><p>load an ASCII SFR output file into a dictionary of kper: dataframes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sfr_out_file</strong> (<cite>str</cite>) – SFR ASCII output file</p></li>
<li><p><strong>selection</strong> (<cite>pandas.DataFrame</cite>) – a dataframe of <cite>reach</cite> and <cite>segment</cite> pairs to
load.  If <cite>None</cite>, all reach-segment pairs are loaded.  Default is <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>aggregates flow to aquifer for segments and returns and flow out at
downstream end of segment.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary of {kper:<cite>pandas.DataFrame</cite>} of SFR output.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><strong>dict</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.modflow_hob_to_instruction_file">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">modflow_hob_to_instruction_file</code><span class="sig-paren">(</span><em class="sig-param">hob_file</em>, <em class="sig-param">ins_file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.modflow_hob_to_instruction_file" title="Permalink to this definition">¶</a></dt>
<dd><p>write an instruction file for a modflow head observation file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hob_file</strong> (<cite>str</cite>) – the path and name of the existing modflow hob file</p></li>
<li><p><strong>ins_file</strong> (<cite>str</cite>, optional) – the name of the instruction file to write.
If <cite>None</cite>, <cite>hob_file</cite> +”.ins” is used.  Default is <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataFrame with control file observation information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.modflow_hydmod_to_instruction_file">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">modflow_hydmod_to_instruction_file</code><span class="sig-paren">(</span><em class="sig-param">hydmod_file</em>, <em class="sig-param">ins_file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.modflow_hydmod_to_instruction_file" title="Permalink to this definition">¶</a></dt>
<dd><p>write an instruction file for a modflow hydmod file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hydmod_file</strong> (<cite>str</cite>) – the path and name of the existing modflow hob file</p></li>
<li><p><strong>ins_file</strong> (<cite>str</cite>, optional) – the name of the instruction file to write.
If <cite>None</cite>, <cite>hydmod_file</cite> +”.ins” is used.  Default is <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataFrame with control file observation information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>calls <cite>pyemu.gw_utils.modflow_read_hydmod_file()</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.modflow_pval_to_template_file">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">modflow_pval_to_template_file</code><span class="sig-paren">(</span><em class="sig-param">pval_file</em>, <em class="sig-param">tpl_file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.modflow_pval_to_template_file" title="Permalink to this definition">¶</a></dt>
<dd><p>write a template file for a modflow parameter value file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pval_file</strong> (<cite>str</cite>) – the path and name of the existing modflow pval file</p></li>
<li><p><strong>tpl_file</strong> (<cite>str</cite>, optional) – template file to write. If None, use
<cite>pval_file</cite> +”.tpl”. Default is None</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Uses names in the first column in the pval file as par names.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataFrame with control file parameter information</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.modflow_read_hydmod_file">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">modflow_read_hydmod_file</code><span class="sig-paren">(</span><em class="sig-param">hydmod_file</em>, <em class="sig-param">hydmod_outfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.modflow_read_hydmod_file" title="Permalink to this definition">¶</a></dt>
<dd><p>read a binary hydmod file and return a dataframe of the results</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hydmod_file</strong> (<cite>str</cite>) – The path and name of the existing modflow hydmod binary file</p></li>
<li><p><strong>hydmod_outfile</strong> (<cite>str</cite>, optional) – output file to write.  If <cite>None</cite>, use <cite>hydmod_file</cite> +”.dat”.
Default is <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataFrame with hymod_file values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.modflow_sfr_gag_to_instruction_file">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">modflow_sfr_gag_to_instruction_file</code><span class="sig-paren">(</span><em class="sig-param">gage_output_file</em>, <em class="sig-param">ins_file=None</em>, <em class="sig-param">parse_filename=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.modflow_sfr_gag_to_instruction_file" title="Permalink to this definition">¶</a></dt>
<dd><p>writes an instruction file for an SFR gage output file to read Flow only at all times</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gage_output_file</strong> (<cite>str</cite>) – the gage output filename (ASCII).</p></li>
<li><p><strong>ins_file</strong> (<cite>str</cite>, optional) – the name of the instruction file to
create.  If None, the name is <cite>gage_output_file</cite> +”.ins”.
Default is None</p></li>
<li><p><strong>parse_filename</strong> (<cite>bool</cite>) – if True, get the gage_num parameter by
parsing the gage output file filename if False, get the gage
number from the file itself</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>pandas.DataFrame</strong>: a dataframe with obsnme and obsval for the sfr simulated flows.</p></li>
<li><p><strong>str</strong>: file name of instructions file relating to gage output.</p></li>
<li><p><strong>str</strong>: file name of processed gage output for all times</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>sets up observations for gage outputs only for the Flow column.</p>
<p>If <cite>parse_namefile</cite> is true, only text up to first ‘.’ is used as the gage_num</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_gage_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_gage_obs</code><span class="sig-paren">(</span><em class="sig-param">gage_file</em>, <em class="sig-param">ins_file=None</em>, <em class="sig-param">start_datetime=None</em>, <em class="sig-param">times=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_gage_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a forward run post processor routine for the modflow gage file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gage_file</strong> (<cite>str</cite>) – the gage output file (ASCII)</p></li>
<li><p><strong>ins_file</strong> (<cite>str</cite>, optional) – the name of the instruction file to create.  If None, the name
is <cite>gage_file`+”.processed.ins”.  Default is `None</cite></p></li>
<li><p><strong>start_datetime</strong> (<cite>str</cite>) – a <cite>pandas.to_datetime()</cite> compatible <cite>str</cite>.  If not <cite>None</cite>,
then the resulting observation names have the datetime suffix.  If <cite>None</cite>,
the suffix is the output totim.  Default is <cite>None</cite>.</p></li>
<li><p><strong>times</strong> ([<cite>float</cite>]) – a container of times to make observations for.  If None,
all times are used. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>pandas.DataFrame</strong>: a dataframe with observation name and simulated values for the
values in the gage file.</p></li>
<li><p><strong>str</strong>: file name of instructions file that was created relating to gage output.</p></li>
<li><p><strong>str</strong>: file name of processed gage output (processed according to times passed above.)</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>setups up observations for gage outputs (all columns).</p>
<p>This is the companion function of <cite>gw_utils.apply_gage_obs()</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_hds_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_hds_obs</code><span class="sig-paren">(</span><em class="sig-param">hds_file</em>, <em class="sig-param">kperk_pairs=None</em>, <em class="sig-param">skip=None</em>, <em class="sig-param">prefix='hds'</em>, <em class="sig-param">text='head'</em>, <em class="sig-param">precision='single'</em>, <em class="sig-param">include_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_hds_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>a function to setup using all values from a layer-stress period
pair for observations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hds_file</strong> (<cite>str</cite>) – path and name of an existing MODFLOW head-save file.
If the hds_file endswith ‘ucn’, then the file is treated as a UcnFile type.</p></li>
<li><p><strong>kperk_pairs</strong> (<em>[</em><em>(</em><em>int</em><em>,</em><em>int</em><em>)</em><em>]</em>) – a list of len two tuples which are pairs of kper
(zero-based stress period index) and k (zero-based layer index) to
setup observations for.  If None, then all layers and stress period records
found in the file will be used.  Caution: a shit-ton of observations may be produced!</p></li>
<li><p><strong>skip</strong> (<em>variable</em>) – a value or function used to determine which values
to skip when setting up observations.  If np.scalar(skip)
is True, then values equal to skip will not be used.
If skip can also be a np.ndarry with dimensions equal to the model.
Observations are set up only for cells with Non-zero values in the array.
If not np.ndarray or np.scalar(skip), then skip will be treated as a lambda function that
returns np.NaN if the value should be skipped.</p></li>
<li><p><strong>prefix</strong> (<cite>str</cite>) – the prefix to use for the observation names. default is “hds”.</p></li>
<li><p><strong>text</strong> (<cite>str</cite>) – the text tag the flopy HeadFile instance.  Default is “head”</p></li>
<li><p><strong>precison</strong> (<cite>str</cite>) – the precision string for the flopy HeadFile instance.  Default is “single”</p></li>
<li><p><strong>include_path</strong> (<cite>bool</cite>, optional) – flag to setup the binary file processing in directory where the hds_file</p></li>
<li><p><strong>located</strong> (<em>is</em>) – the process in separate directory for where python is running.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>str</strong>: the forward run script line needed to execute the headsave file observation
operation</p></li>
<li><p><strong>pandas.DataFrame</strong>: a dataframe of pest control file information</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Writes an instruction file and a _setup_ csv used construct a control file.</p>
<p>This is the companion function to <cite>gw_utils.apply_hds_obs()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_hds_timeseries">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_hds_timeseries</code><span class="sig-paren">(</span><em class="sig-param">bin_file</em>, <em class="sig-param">kij_dict</em>, <em class="sig-param">prefix=None</em>, <em class="sig-param">include_path=False</em>, <em class="sig-param">model=None</em>, <em class="sig-param">postprocess_inact=None</em>, <em class="sig-param">text=None</em>, <em class="sig-param">fill=None</em>, <em class="sig-param">precision='single'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_hds_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>a function to setup a forward process to extract time-series style values
from a binary modflow binary file (or equivalent format - hds, ucn, sub, cbb, etc).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bin_file</strong> (<cite>str</cite>) – path and name of existing modflow binary file - headsave, cell budget and MT3D UCN supported.</p></li>
<li><p><strong>kij_dict</strong> (<cite>dict</cite>) – dictionary of site_name: [k,i,j] pairs. For example: <cite>{“wel1”:[0,1,1]}</cite>.</p></li>
<li><p><strong>prefix</strong> (<cite>str</cite>, optional) – string to prepend to site_name when forming observation names.  Default is None</p></li>
<li><p><strong>include_path</strong> (<cite>bool</cite>, optional) – flag to setup the binary file processing in directory where the hds_file</p></li>
<li><p><strong>located</strong> (<em>is</em>) – the process in separate directory for where python is running.</p></li>
<li><p><strong>model</strong> (<cite>flopy.mbase</cite>, optional) – a <cite>flopy.basemodel</cite> instance.  If passed, the observation names will
have the datetime of the observation appended to them (using the flopy <cite>start_datetime</cite> attribute.
If None, the observation names will have the zero-based stress period appended to them. Default is None.</p></li>
<li><p><strong>postprocess_inact</strong> (<cite>float</cite>, optional) – Inactive value in heads/ucn file e.g. mt.btn.cinit.  If <cite>None</cite>, no
inactive value processing happens.  Default is <cite>None</cite>.</p></li>
<li><p><strong>text</strong> (<cite>str</cite>) – the text record entry in the binary file (e.g. “constant_head”).
Used to indicate that the binary file is a MODFLOW cell-by-cell budget file.
If None, headsave or MT3D unformatted concentration file
is assummed.  Default is None</p></li>
<li><p><strong>fill</strong> (<cite>float</cite>) – fill value for NaNs in the extracted timeseries dataframe.  If
<cite>None</cite>, no filling is done, which may yield model run failures as the resulting
processed timeseries CSV file (produced at runtime) may have missing values and
can’t be processed with the cooresponding instruction file.  Default is <cite>None</cite>.</p></li>
<li><p><strong>precision</strong> (<cite>str</cite>) – the precision of the binary file.  Can be “single” or “double”.
Default is “single”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>str</strong>: the forward run command to execute the binary file process during model runs.</p></li>
<li><p><strong>pandas.DataFrame</strong>: a dataframe of observation information for use in the pest control file</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function writes hds_timeseries.config that must be in the same
dir where <cite>apply_hds_timeseries()</cite> is called during the forward run</p>
<p>Assumes model time units are days</p>
<p>this is the companion function of <cite>gw_utils.apply_hds_timeseries()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_mflist_budget_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_mflist_budget_obs</code><span class="sig-paren">(</span><em class="sig-param">list_filename</em>, <em class="sig-param">flx_filename='flux.dat'</em>, <em class="sig-param">vol_filename='vol.dat'</em>, <em class="sig-param">start_datetime=&quot;1-1'1970&quot;</em>, <em class="sig-param">prefix=''</em>, <em class="sig-param">save_setup_file=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_mflist_budget_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>setup observations of budget volume and flux from modflow list file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_filename</strong> (<cite>str</cite>) – path and name of the existing modflow list file</p></li>
<li><p><strong>flx_filename</strong> (<cite>str</cite>, optional) – output filename that will contain the budget flux
observations. Default is “flux.dat”</p></li>
<li><p><strong>vol_filename</strong> (<cite>str</cite>, optional) – output filename that will contain the budget volume
observations.  Default is “vol.dat”</p></li>
<li><p><strong>start_datetime</strong> (<cite>str</cite>, optional) – a string that can be parsed into a pandas.TimeStamp.
This is used to give budget observations meaningful names.  Default is “1-1-1970”.</p></li>
<li><p><strong>prefix</strong> (<cite>str</cite>, optional) – a prefix to add to the water budget observations.  Useful if
processing more than one list file as part of the forward run process. Default is ‘’.</p></li>
<li><p><strong>save_setup_file</strong> (<cite>bool</cite>) – a flag to save “_setup_”+ <cite>list_filename</cite> +”.csv” file that contains useful
control file information</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with information for constructing a control file.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method writes instruction files and also a _setup_.csv to use when constructing a pest
control file.  The instruction files are named &lt;flux_file&gt;.ins and &lt;vol_file&gt;.ins, respectively</p>
<p>It is recommended to use the default values for flux_file and vol_file.</p>
<p>This is the companion function of <cite>gw_utils.apply_mflist_budget_obs()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_mtlist_budget_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_mtlist_budget_obs</code><span class="sig-paren">(</span><em class="sig-param">list_filename</em>, <em class="sig-param">gw_filename='mtlist_gw.dat'</em>, <em class="sig-param">sw_filename='mtlist_sw.dat'</em>, <em class="sig-param">start_datetime='1-1-1970'</em>, <em class="sig-param">gw_prefix='gw'</em>, <em class="sig-param">sw_prefix='sw'</em>, <em class="sig-param">save_setup_file=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_mtlist_budget_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>setup observations of gw (and optionally sw) mass budgets from mt3dusgs list file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_filename</strong> (<cite>str</cite>) – path and name of existing modflow list file</p></li>
<li><p><strong>gw_filename</strong> (<cite>str</cite>, optional) – output filename that will contain the gw budget
observations. Default is “mtlist_gw.dat”</p></li>
<li><p><strong>sw_filename</strong> (<cite>str</cite>, optional) – output filename that will contain the sw budget
observations. Default is “mtlist_sw.dat”</p></li>
<li><p><strong>start_datetime</strong> (<cite>str</cite>, optional) – an str that can be parsed into a <cite>pandas.TimeStamp</cite>.
used to give budget observations meaningful names.  Default is “1-1-1970”.</p></li>
<li><p><strong>gw_prefix</strong> (<cite>str</cite>, optional) – a prefix to add to the GW budget observations.
Useful if processing more than one list file as part of the forward run process.
Default is ‘gw’.</p></li>
<li><p><strong>sw_prefix</strong> (<cite>str</cite>, optional) – a prefix to add to the SW budget observations.  Useful
if processing more than one list file as part of the forward run process.
Default is ‘sw’.</p></li>
<li><p><strong>save_setup_file</strong> (<cite>bool</cite>, optional) – a flag to save “_setup_”+ <cite>list_filename</cite> +”.csv” file
that contains useful control file information.  Default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>str</strong>:  the command to add to the forward run script</p></li>
<li><p><strong>str</strong>: the names of the instruction files that were created</p></li>
<li><p><strong>pandas.DataFrame</strong>: a dataframe with information for constructing a control file</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>writes an instruction file and also a _setup_.csv to use when constructing a pest</dt><dd><p>control file</p>
</dd>
</dl>
<p>the instruction files are named <cite>out_filename</cite> +”.ins”</p>
<p>It is recommended to use the default value for <cite>gw_filename</cite> or <cite>sw_filename</cite>.</p>
<p>This is the companion function of <cite>gw_utils.apply_mtlist_budget_obs()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_sfr_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_sfr_obs</code><span class="sig-paren">(</span><em class="sig-param">sfr_out_file</em>, <em class="sig-param">seg_group_dict=None</em>, <em class="sig-param">ins_file=None</em>, <em class="sig-param">model=None</em>, <em class="sig-param">include_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_sfr_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>setup observations using the sfr ASCII output file.  Setups
the ability to aggregate flows for groups of segments.  Applies
only flow to aquier and flow out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sft_out_file</strong> (<cite>str</cite>) – the name and path to an existing SFR output file</p></li>
<li><p><strong>seg_group_dict</strong> (<cite>dict</cite>) – a dictionary of SFR segements to aggregate together for a single obs.
the key value in the dict is the base observation name. If None, all segments
are used as individual observations. Default is None</p></li>
<li><p><strong>model</strong> (<cite>flopy.mbase</cite>) – a flopy model.  If passed, the observation names will have
the datetime of the observation appended to them.  If None, the observation names
will have the stress period appended to them. Default is None.</p></li>
<li><p><strong>include_path</strong> (<cite>bool</cite>) – flag to prepend sfr_out_file path to sfr_obs.config.  Useful for setting up
process in separate directory for where python is running.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dataframe of observation name, simulated value and group.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the companion function of <cite>gw_utils.apply_sfr_obs()</cite>.</p>
<p>This function writes “sfr_obs.config” which must be kept in the dir where
“gw_utils.apply_sfr_obs()” is being called during the forward run</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_sfr_reach_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_sfr_reach_obs</code><span class="sig-paren">(</span><em class="sig-param">sfr_out_file</em>, <em class="sig-param">seg_reach=None</em>, <em class="sig-param">ins_file=None</em>, <em class="sig-param">model=None</em>, <em class="sig-param">include_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_sfr_reach_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>setup observations using the sfr ASCII output file.  Setups
sfr point observations using segment and reach numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sft_out_file</strong> (<cite>str</cite>) – the path and name of an existing SFR output file</p></li>
<li><p><strong>seg_reach</strong> (<em>varies</em>) – a dict, or list of SFR [segment,reach] pairs identifying
locations of interest.  If <cite>dict</cite>, the key value in the dict is the base
observation name. If None, all reaches are used as individual observations.
Default is None - THIS MAY SET UP A LOT OF OBS!</p></li>
<li><p><strong>model</strong> (<cite>flopy.mbase</cite>) – a flopy model.  If passed, the observation names will
have the datetime of the observation appended to them.  If None, the
observation names will have the stress period appended to them. Default is None.</p></li>
<li><p><strong>include_path</strong> (<cite>bool</cite>) – a flag to prepend sfr_out_file path to sfr_obs.config.  Useful
for setting up process in separate directory for where python is running.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe of observation names, values, and groups</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pd.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the companion function of <cite>gw_utils.apply_sfr_reach_obs()</cite>.</p>
<p>This function writes “sfr_reach_obs.config” which must be kept in the dir where
“apply_sfr_reach_obs()” is being called during the forward run</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_sfr_reach_parameters">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_sfr_reach_parameters</code><span class="sig-paren">(</span><em class="sig-param">nam_file, model_ws='.', par_cols=['strhc1']</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_sfr_reach_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup multiplier paramters for reach data, when reachinput option is specififed in sfr.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nam_file</strong> (<cite>str</cite>) – MODFLOw name file.  DIS, BAS, and SFR must be
available as pathed in the nam_file.  Optionally, <cite>nam_file</cite> can be
an existing <cite>flopy.modflow.Modflow</cite>.</p></li>
<li><p><strong>model_ws</strong> (<cite>str</cite>) – model workspace for flopy to load the MODFLOW model from</p></li>
<li><p><strong>par_cols</strong> ([<cite>str</cite>]) – a list of segment data entires to parameterize</p></li>
<li><p><strong>tie_hcond</strong> (<cite>bool</cite>) – flag to use same mult par for hcond1 and hcond2 for a
given segment.  Default is <cite>True</cite>.</p></li>
<li><p><strong>include_temporal_pars</strong> ([<cite>str</cite>]) – list of spatially-global multipliers to set up for
each stress period.  Default is None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with useful parameter setup information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Similar to <cite>gw_utils.setup_sfr_seg_parameters()</cite>, method will apply params to sfr reachdata</p>
<dl class="simple">
<dt>Can load the dis, bas, and sfr files with flopy using model_ws. Or can pass a model object</dt><dd><p>(SFR loading can be slow)</p>
</dd>
</dl>
<p>This is the companion function of <cite>gw_utils.apply_sfr_reach_parameters()</cite></p>
<p>Skips values = 0.0 since multipliers don’t work for these</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_sfr_seg_parameters">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_sfr_seg_parameters</code><span class="sig-paren">(</span><em class="sig-param">nam_file</em>, <em class="sig-param">model_ws='.'</em>, <em class="sig-param">par_cols=None</em>, <em class="sig-param">tie_hcond=True</em>, <em class="sig-param">include_temporal_pars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_sfr_seg_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup multiplier parameters for SFR segment data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nam_file</strong> (<cite>str</cite>) – MODFLOw name file.  DIS, BAS, and SFR must be
available as pathed in the nam_file.  Optionally, <cite>nam_file</cite> can be
an existing <cite>flopy.modflow.Modflow</cite>.</p></li>
<li><p><strong>model_ws</strong> (<cite>str</cite>) – model workspace for flopy to load the MODFLOW model from</p></li>
<li><p><strong>par_cols</strong> ([<cite>str</cite>]) – a list of segment data entires to parameterize</p></li>
<li><p><strong>tie_hcond</strong> (<cite>bool</cite>) – flag to use same mult par for hcond1 and hcond2 for a
given segment.  Default is <cite>True</cite>.</p></li>
<li><p><strong>include_temporal_pars</strong> ([<cite>str</cite>]) – list of spatially-global multipliers to set up for
each stress period.  Default is None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with useful parameter setup information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl>
<dt>This function handles the standard input case, not all the cryptic SFR options.  Loads the</dt><dd><blockquote>
<div><p>dis, bas, and sfr files with flopy using model_ws.</p>
</div></blockquote>
<p>This is the companion function to <cite>gw_utils.apply_sfr_seg_parameters()</cite> .</p>
<dl class="simple">
<dt>The number (and numbering) of segment data entries must consistent across</dt><dd><p>all stress periods.</p>
</dd>
</dl>
<p>Writes <cite>nam_file</cite> +”_backup_.sfr” as the backup of the original sfr file</p>
<p>Skips values = 0.0 since multipliers don’t work for these</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.setup_sft_obs">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">setup_sft_obs</code><span class="sig-paren">(</span><em class="sig-param">sft_file</em>, <em class="sig-param">ins_file=None</em>, <em class="sig-param">start_datetime=None</em>, <em class="sig-param">times=None</em>, <em class="sig-param">ncomp=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.setup_sft_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>writes a post-processor and instruction file for a mt3d-usgs sft output file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sft_file</strong> (<cite>str</cite>) – path and name of an existing sft output file (ASCII)</p></li>
<li><p><strong>ins_file</strong> (<cite>str</cite>, optional) – the name of the instruction file to create.
If None, the name is <cite>sft_file`+”.ins”.  Default is `None</cite>.</p></li>
<li><p><strong>start_datetime</strong> (<cite>str</cite>) – a pandas.to_datetime() compatible str.  If not None,
then the resulting observation names have the datetime
suffix.  If None, the suffix is the output totim.  Default
is <cite>None</cite>.</p></li>
<li><p><strong>times</strong> ([<cite>float</cite>]) – a list of times to make observations for.  If None, all times
found in the file are used. Default is None.</p></li>
<li><p><strong>ncomp</strong> (<cite>int</cite>) – number of components in transport model. Default is 1.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this is the companion function to <cite>gw_utils.apply_sft_obs()</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dataframe with observation names and values for the sft simulated
concentrations.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><strong>pandas.DataFrame</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.write_hfb_template">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">write_hfb_template</code><span class="sig-paren">(</span><em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.write_hfb_template" title="Permalink to this definition">¶</a></dt>
<dd><p>write a template file for an hfb (yuck!)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>m</strong> – a model instance with an HFB package</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.gw_utils.write_hfb_zone_multipliers_template">
<code class="sig-prename descclassname">pyemu.utils.gw_utils.</code><code class="sig-name descname">write_hfb_zone_multipliers_template</code><span class="sig-paren">(</span><em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.gw_utils.write_hfb_zone_multipliers_template" title="Permalink to this definition">¶</a></dt>
<dd><p>write a template file for an hfb using multipliers per zone (double yuck!)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>m</strong> (<cite>flopy.modflow.Modflow</cite>) – a model instance with an HFB package</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>dict</strong>: a dictionary with original unique HFB conductivity values and their
corresponding parameter names</p></li>
<li><p><strong>str</strong>: the template filename that was created</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyemu.utils.helpers"></span><p>High-level functions to help perform complex tasks</p>
<dl class="class">
<dt id="pyemu.utils.helpers.PstFromFlopyModel">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">PstFromFlopyModel</code><span class="sig-paren">(</span><em class="sig-param">model</em>, <em class="sig-param">new_model_ws</em>, <em class="sig-param">org_model_ws=None</em>, <em class="sig-param">pp_props=[]</em>, <em class="sig-param">const_props=[]</em>, <em class="sig-param">temporal_bc_props=[]</em>, <em class="sig-param">temporal_list_props=[]</em>, <em class="sig-param">grid_props=[]</em>, <em class="sig-param">grid_geostruct=None</em>, <em class="sig-param">pp_space=None</em>, <em class="sig-param">zone_props=[]</em>, <em class="sig-param">pp_geostruct=None</em>, <em class="sig-param">par_bounds_dict=None</em>, <em class="sig-param">sfr_pars=False</em>, <em class="sig-param">temporal_sfr_pars=False</em>, <em class="sig-param">temporal_list_geostruct=None</em>, <em class="sig-param">remove_existing=False</em>, <em class="sig-param">k_zone_dict=None</em>, <em class="sig-param">mflist_waterbudget=True</em>, <em class="sig-param">mfhyd=True</em>, <em class="sig-param">hds_kperk=[]</em>, <em class="sig-param">use_pp_zones=False</em>, <em class="sig-param">obssim_smp_pairs=None</em>, <em class="sig-param">external_tpl_in_pairs=None</em>, <em class="sig-param">external_ins_out_pairs=None</em>, <em class="sig-param">extra_pre_cmds=None</em>, <em class="sig-param">extra_model_cmds=None</em>, <em class="sig-param">extra_post_cmds=None</em>, <em class="sig-param">redirect_forward_output=True</em>, <em class="sig-param">tmp_files=None</em>, <em class="sig-param">model_exe_name=None</em>, <em class="sig-param">build_prior=True</em>, <em class="sig-param">sfr_obs=False</em>, <em class="sig-param">spatial_bc_props=[]</em>, <em class="sig-param">spatial_list_props=[]</em>, <em class="sig-param">spatial_list_geostruct=None</em>, <em class="sig-param">hfb_pars=False</em>, <em class="sig-param">kl_props=None</em>, <em class="sig-param">kl_num_eig=100</em>, <em class="sig-param">kl_geostruct=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.PstFromFlopyModel" title="Permalink to this definition">¶</a></dt>
<dd><p>a monster helper class to setup a complex PEST interface around
an existing MODFLOW-2005-family model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<cite>flopy.mbase</cite>) – a loaded flopy model instance. If model is an str, it is treated as a
MODFLOW nam file (requires org_model_ws)</p></li>
<li><p><strong>new_model_ws</strong> (<cite>str</cite>) – a directory where the new version of MODFLOW input files and PEST(++)
files will be written</p></li>
<li><p><strong>org_model_ws</strong> (<cite>str</cite>) – directory to existing MODFLOW model files.  Required if model argument
is an str.  Default is None</p></li>
<li><p><strong>pp_props</strong> ([[<cite>str</cite>,[<cite>int</cite>]]]) – pilot point multiplier parameters for grid-based properties.
A nested list of grid-scale model properties to parameterize using
name, iterable pairs.  For 3D properties, the iterable is zero-based
layer indices.  For example, [“lpf.hk”,[0,1,2,]] would setup pilot point multiplier
parameters for layer property file horizontal hydraulic conductivity for model
layers 1,2, and 3.  For time-varying properties (e.g. recharge), the
iterable is for zero-based stress period indices.  For example, [“rch.rech”,[0,4,10,15]]
would setup pilot point multiplier parameters for recharge for stress
period 1,5,11,and 16.</p></li>
<li><p><strong>const_props</strong> ([[<cite>str</cite>,[<cite>int</cite>]]]) – constant (uniform) multiplier parameters for grid-based properties.
A nested list of grid-scale model properties to parameterize using
name, iterable pairs.  For 3D properties, the iterable is zero-based
layer indices.  For example, [“lpf.hk”,[0,1,2,]] would setup constant (uniform) multiplier
parameters for layer property file horizontal hydraulic conductivity for model
layers 1,2, and 3.  For time-varying properties (e.g. recharge), the
iterable is for zero-based stress period indices.  For example, [“rch.rech”,[0,4,10,15]]
would setup constant (uniform) multiplier parameters for recharge for stress
period 1,5,11,and 16.</p></li>
<li><p><strong>temporal_list_props</strong> ([[<cite>str</cite>,[<cite>int</cite>]]]) – list-type input stress-period level multiplier parameters.
A nested list of list-type input elements to parameterize using
name, iterable pairs.  The iterable is zero-based stress-period indices.
For example, to setup multipliers for WEL flux and for RIV conductance,
temporal_list_props = [[“wel.flux”,[0,1,2]],[“riv.cond”,None]] would setup
multiplier parameters for well flux for stress periods 1,2 and 3 and
would setup one single river conductance multiplier parameter that is applied
to all stress periods</p></li>
<li><p><strong>spatial_list_props</strong> ([[<cite>str</cite>,[<cite>int</cite>]]]) – list-type input for spatial multiplier parameters.
A nested list of list-type elements to parameterize using
names (e.g. [[“riv.cond”,0],[“wel.flux”,1] to setup up cell-based parameters for
each list-type element listed.  These multiplier parameters are applied across
all stress periods.  For this to work, there must be the same number of entries
for all stress periods.  If more than one list element of the same type is in a single
cell, only one parameter is used to multiply all lists in the same cell.</p></li>
<li><p><strong>grid_props</strong> ([[<cite>str</cite>,[<cite>int</cite>]]]) – grid-based (every active model cell) multiplier parameters.
A nested list of grid-scale model properties to parameterize using
name, iterable pairs.  For 3D properties, the iterable is zero-based
layer indices (e.g., [“lpf.hk”,[0,1,2,]] would setup a multiplier
parameter for layer property file horizontal hydraulic conductivity for model
layers 1,2, and 3 in every active model cell).  For time-varying properties (e.g. recharge), the
iterable is for zero-based stress period indices.  For example, [“rch.rech”,[0,4,10,15]]
would setup grid-based multiplier parameters in every active model cell
for recharge for stress period 1,5,11,and 16.</p></li>
<li><p><strong>sfr_pars</strong> (<cite>bool</cite>) – setup parameters for the stream flow routing modflow package.
If list is passed it defines the parameters to set up.</p></li>
<li><p><strong>sfr_temporal_pars</strong> (<cite>bool</cite>) – flag to include stress-period level spatially-global multipler parameters in addition to
the spatially-discrete <cite>sfr_pars</cite>.  Requires <cite>sfr_pars</cite> to be passed.  Default is False</p></li>
<li><p><strong>grid_geostruct</strong> (<cite>pyemu.geostats.GeoStruct</cite>) – the geostatistical structure to build the prior parameter covariance matrix
elements for grid-based parameters.  If None, a generic GeoStruct is created
using an “a” parameter that is 10 times the max cell size.  Default is None</p></li>
<li><p><strong>pp_space</strong> (<cite>int</cite>) – number of grid cells between pilot points.  If None, use the default
in pyemu.pp_utils.setup_pilot_points_grid.  Default is None</p></li>
<li><p><strong>zone_props</strong> ([[<cite>str</cite>,[<cite>int</cite>]]]) – zone-based multiplier parameters.
A nested list of zone-based model properties to parameterize using
name, iterable pairs.  For 3D properties, the iterable is zero-based
layer indices (e.g., [“lpf.hk”,[0,1,2,]] would setup a multiplier
parameter for layer property file horizontal hydraulic conductivity for model
layers 1,2, and 3 for unique zone values in the ibound array.
For time-varying properties (e.g. recharge), the iterable is for
zero-based stress period indices.  For example, [“rch.rech”,[0,4,10,15]]
would setup zone-based multiplier parameters for recharge for stress
period 1,5,11,and 16.</p></li>
<li><p><strong>pp_geostruct</strong> (<cite>pyemu.geostats.GeoStruct</cite>) – the geostatistical structure to use for building the prior parameter
covariance matrix for pilot point parameters.  If None, a generic
GeoStruct is created using pp_space and grid-spacing information.
Default is None</p></li>
<li><p><strong>par_bounds_dict</strong> (<cite>dict</cite>) – a dictionary of model property/boundary condition name, upper-lower bound pairs.
For example, par_bounds_dict = {“hk”:[0.01,100.0],”flux”:[0.5,2.0]} would
set the bounds for horizontal hydraulic conductivity to
0.001 and 100.0 and set the bounds for flux parameters to 0.5 and
2.0.  For parameters not found in par_bounds_dict,
<cite>pyemu.helpers.wildass_guess_par_bounds_dict</cite> is
used to set somewhat meaningful bounds.  Default is None</p></li>
<li><p><strong>temporal_list_geostruct</strong> (<cite>pyemu.geostats.GeoStruct</cite>) – the geostastical struture to
build the prior parameter covariance matrix
for time-varying list-type multiplier parameters.  This GeoStruct
express the time correlation so that the ‘a’ parameter is the length of
time that boundary condition multiplier parameters are correlated across.
If None, then a generic GeoStruct is created that uses an ‘a’ parameter
of 3 stress periods.  Default is None</p></li>
<li><p><strong>spatial_list_geostruct</strong> (<cite>pyemu.geostats.GeoStruct</cite>) – the geostastical struture to
build the prior parameter covariance matrix
for spatially-varying list-type multiplier parameters.
If None, a generic GeoStruct is created using an “a” parameter that
is 10 times the max cell size.  Default is None.</p></li>
<li><p><strong>remove_existing</strong> (<cite>bool</cite>) – a flag to remove an existing new_model_ws directory.  If False and
new_model_ws exists, an exception is raised.  If True and new_model_ws
exists, the directory is destroyed - user beware! Default is False.</p></li>
<li><p><strong>k_zone_dict</strong> (<cite>dict</cite>) – a dictionary of zero-based layer index, zone array pairs.
e.g. {lay: np.2darray}  Used to
override using ibound zones for zone-based parameterization.  If None,
use ibound values greater than zero as zones. Alternatively a dictionary of dictionaries
can be passed to allow different zones to be defined for different parameters.
e.g. {“upw.hk” {lay: np.2darray}, “extra.rc11” {lay: np.2darray}}
or {“hk” {lay: np.2darray}, “rc11” {lay: np.2darray}}</p></li>
<li><p><strong>use_pp_zones</strong> (<cite>bool</cite>) – a flag to use ibound zones (or k_zone_dict, see above) as pilot
point zones.  If False, ibound values greater than zero are treated as
a single zone for pilot points.  Default is False</p></li>
<li><p><strong>(</strong><strong>[</strong><strong>[</strong><strong>str</strong><strong>,</strong><strong>`str`</strong><strong>]</strong><strong>]</strong> (<em>external_ins_out_pairs</em>) – a list of observed-simulated PEST-type SMP file
pairs to get observations
from and include in the control file.  Default is []</p></li>
<li><p><strong>(</strong><strong>[</strong><strong>[</strong><strong>str</strong><strong>,</strong><strong>`str`</strong><strong>]</strong><strong>]</strong> – a list of existing template file, model input
file pairs to parse parameters
from and include in the control file.  Default is []</p></li>
<li><p><strong>(</strong><strong>[</strong><strong>[</strong><strong>str</strong><strong>,</strong><strong>`str`</strong><strong>]</strong><strong>]</strong> – a list of existing instruction file,
model output file pairs to parse
observations from and include in the control file.  Default is []</p></li>
<li><p><strong>extra_pre_cmds</strong> ([<cite>str</cite>]) – a list of preprocessing commands to add to the forward_run.py script
commands are executed with os.system() within forward_run.py. Default is None.</p></li>
<li><p><strong>redirect_forward_output</strong> (<cite>bool</cite>) – flag for whether to redirect forward model output to text files (True) or
allow model output to be directed to the screen (False).  Default is True</p></li>
<li><p><strong>extra_post_cmds</strong> ([<cite>str</cite>]) – a list of post-processing commands to add to the forward_run.py script.
Commands are executed with os.system() within forward_run.py. Default is None.</p></li>
<li><p><strong>tmp_files</strong> ([<cite>str</cite>]) – a list of temporary files that should be removed at the start of the forward
run script.  Default is [].</p></li>
<li><p><strong>model_exe_name</strong> (<cite>str</cite>) – binary name to run modflow.  If None, a default from flopy is used,
which is dangerous because of the non-standard binary names
(e.g. MODFLOW-NWT_x64, MODFLOWNWT, mfnwt, etc). Default is None.</p></li>
<li><p><strong>build_prior</strong> (<cite>bool</cite>) – flag to build prior covariance matrix. Default is True</p></li>
<li><p><strong>sfr_obs</strong> (<cite>bool</cite>) – flag to include observations of flow and aquifer exchange from
the sfr ASCII output file</p></li>
<li><p><strong>hfb_pars</strong> (<cite>bool</cite>) – add HFB parameters.  uses pyemu.gw_utils.write_hfb_template().  the resulting
HFB pars have parval1 equal to the values in the original file and use the
spatial_list_geostruct to build geostatistical covariates between parameters</p></li>
<li><p><strong>kl_props</strong> ([[<cite>str</cite>,[<cite>int</cite>]]]) – karhunen-loeve based multiplier parameters.
A nested list of KL-based model properties to parameterize using
name, iterable pairs.  For 3D properties, the iterable is zero-based
layer indices (e.g., [“lpf.hk”,[0,1,2,]] would setup a multiplier
parameter for layer property file horizontal hydraulic conductivity for model
layers 1,2, and 3 for unique zone values in the ibound array.
For time-varying properties (e.g. recharge), the iterable is for
zero-based stress period indices.  For example, [“rch.rech”,[0,4,10,15]]
would setup zone-based multiplier parameters for recharge for stress
period 1,5,11,and 16.</p></li>
<li><p><strong>kl_num_eig</strong> (<cite>int</cite>) – the number of KL-based eigenvector multiplier parameters to use for each
KL parameter set. default is 100</p></li>
<li><p><strong>kl_geostruct</strong> (<cite>pyemu.geostats.Geostruct</cite>) – the geostatistical structure
to build the prior parameter covariance matrix
elements for KL-based parameters.  If None, a generic GeoStruct is created
using an “a” parameter that is 10 times the max cell size.  Default is None</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setup up multiplier parameters for an existing MODFLOW model.</p>
<p>Does all kinds of coolness like building a
meaningful prior, assigning somewhat meaningful parameter groups and
bounds, writes a forward_run.py script with all the calls need to
implement multiplier parameters, run MODFLOW and post-process.</p>
<p>Works a lot better if TEMPCHEK, INSCHEK and PESTCHEK are available in the
system path variable</p>
</div>
<dl class="method">
<dt id="pyemu.utils.helpers.PstFromFlopyModel.build_prior">
<code class="sig-name descname">build_prior</code><span class="sig-paren">(</span><em class="sig-param">fmt='ascii'</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">droptol=None</em>, <em class="sig-param">chunk=None</em>, <em class="sig-param">sigma_range=6</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.PstFromFlopyModel.build_prior" title="Permalink to this definition">¶</a></dt>
<dd><p>build and optionally save the prior parameter covariance matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fmt</strong> (<cite>str</cite>, optional) – the format to save the cov matrix.  Options are “ascii”,”binary”,”uncfile”, “coo”.
Default is “ascii”.  If “none” (lower case string, not None), then no file is created.</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>, optional) – the filename to save the prior cov matrix to.  If None, the name is formed using
model nam_file name.  Default is None.</p></li>
<li><p><strong>droptol</strong> (<cite>float</cite>, optional) – tolerance for dropping near-zero values when writing compressed binary.
Default is None.</p></li>
<li><p><strong>chunk</strong> (<cite>int</cite>, optional) – chunk size to write in a single pass - for binary only.  Default
is None (no chunking).</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>) – number of standard deviations represented by the parameter bounds.  Default
is 6.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the full prior parameter covariance matrix, generated by processing parameters by
groups</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.helpers.PstFromFlopyModel.build_pst">
<code class="sig-name descname">build_pst</code><span class="sig-paren">(</span><em class="sig-param">filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.PstFromFlopyModel.build_pst" title="Permalink to this definition">¶</a></dt>
<dd><p>build the pest control file using the parameters and
observations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – the filename to save the contorl file to.  If None, the
name if formed from the model namfile name.  Default is None.  The control
is saved in the <cite>PstFromFlopy.m.model_ws</cite> directory.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>calls pyemu.Pst.from_io_files</p>
<p>calls PESTCHEK</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.helpers.PstFromFlopyModel.draw">
<code class="sig-name descname">draw</code><span class="sig-paren">(</span><em class="sig-param">num_reals=100</em>, <em class="sig-param">sigma_range=6</em>, <em class="sig-param">use_specsim=False</em>, <em class="sig-param">scale_offset=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.PstFromFlopyModel.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>draw from the geostatistically-implied parameter covariance matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_reals</strong> (<cite>int</cite>) – number of realizations to generate. Default is 100</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>) – number of standard deviations represented by
the parameter bounds.  Default is 6.</p></li>
<li><p><strong>use_specsim</strong> (<cite>bool</cite>) – flag to use spectral simulation for grid-based
parameters.  Requires a regular grid but is wicked fast.  Default is False</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>, optional) – flag to apply scale and offset to parameter
bounds when calculating variances - this is passed through to
<cite>pyemu.Cov.from_parameter_data</cite>.  Default is True.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>operates on parameters by groups to avoid having to construct a very large
covariance matrix for problems with more the 30K parameters.</p>
<p>uses <cite>helpers.geostatitical_draw()</cite></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The realized parameter ensemble</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.ParameterEnsemble</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.helpers.PstFromFlopyModel.write_forward_run">
<code class="sig-name descname">write_forward_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.PstFromFlopyModel.write_forward_run" title="Permalink to this definition">¶</a></dt>
<dd><p>write the forward run script forward_run.py</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method can be called repeatedly, especially after any
changed to the pre- and/or post-processing routines.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.apply_array_pars">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">apply_array_pars</code><span class="sig-paren">(</span><em class="sig-param">arr_par_file='arr_pars.csv'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.apply_array_pars" title="Permalink to this definition">¶</a></dt>
<dd><p>a function to apply array-based multipler parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr_par_file</strong> (<cite>str</cite>) – path to csv file detailing parameter array multipliers.
This file is written by PstFromFlopy.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Used to implement the parameterization constructed by
PstFromFlopyModel during a forward run</p>
<p>This function should be added to the forward_run.py script but can
be called on any correctly formatted csv</p>
<p>This function using multiprocessing, spawning one process for each
model input array (and optionally pp files).  This speeds up
execution time considerably but means you need to make sure your
forward run script uses the proper multiprocessing idioms for
freeze support and main thread handling.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.apply_list_pars">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">apply_list_pars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.apply_list_pars" title="Permalink to this definition">¶</a></dt>
<dd><p>a function to apply boundary condition multiplier parameters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Used to implement the parameterization constructed by
PstFromFlopyModel during a forward run</p>
<p>Requires either “temporal_list_pars.csv” or “spatial_list_pars.csv”</p>
<p>Should be added to the forward_run.py script</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.apply_temporal_diff_obs">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">apply_temporal_diff_obs</code><span class="sig-paren">(</span><em class="sig-param">config_file</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.apply_temporal_diff_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>process an instruction-output file pair and formulate difference observations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>config_file</strong> (<cite>str</cite>) – configuration file written by <cite>pyemu.helpers.setup_temporal_diff_obs</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>processed difference observations</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>diff_df (<cite>pandas.DataFrame</cite>)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>writes <cite>config_file.replace(“.config”,”.processed”)</cite> output file that can be read
with the instruction file that is created by <cite>pyemu.helpers.setup_temporal_diff_obs()</cite>.</p>
<p>this is the companion function of <cite>helpers.setup_setup_temporal_diff_obs()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.build_jac_test_csv">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">build_jac_test_csv</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">num_steps</em>, <em class="sig-param">par_names=None</em>, <em class="sig-param">forward=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.build_jac_test_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>build a dataframe of jactest inputs for use with sweep</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – existing control file</p></li>
<li><p><strong>num_steps</strong> (<cite>int</cite>) – number of pertubation steps for each parameter</p></li>
<li><p><strong>[</strong><strong>str</strong><strong>]</strong> (<em>par_names</em>) – list of parameter names of pars to test.
If None, all adjustable pars are used. Default is None</p></li>
<li><p><strong>forward</strong> (<cite>bool</cite>) – flag to start with forward pertubations.
Default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the sequence of model runs to evaluate
for the jactesting.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.first_order_pearson_tikhonov">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">first_order_pearson_tikhonov</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">cov</em>, <em class="sig-param">reset=True</em>, <em class="sig-param">abs_drop_tol=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.first_order_pearson_tikhonov" title="Permalink to this definition">¶</a></dt>
<dd><p>setup preferred-difference regularization from a covariance matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – the PEST control file</p></li>
<li><p><strong>cov</strong> (<cite>pyemu.Cov</cite>) – a covariance matrix instance with
some or all of the parameters listed in <cite>pst</cite>.</p></li>
<li><p><strong>reset</strong> (<cite>bool</cite>) – a flag to remove any existing prior information equations
in the control file.  Default is True</p></li>
<li><p><strong>abs_drop_tol</strong> (<cite>float</cite>, optional) – tolerance to control how many pi equations
are written. If the absolute value of the Pearson CC is less than
abs_drop_tol, the prior information equation will not be included in
the control file.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The weights on the prior information equations are the Pearson
correlation coefficients implied by covariance matrix.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Cov</span><span class="o">.</span><span class="n">from_ascii</span><span class="p">(</span><span class="s2">&quot;my.cov&quot;</span><span class="p">)</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">helpers</span><span class="o">.</span><span class="n">first_order_pearson_tikhonov</span><span class="p">(</span><span class="n">pst</span><span class="p">,</span><span class="n">cov</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;my_reg.pst&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.geostatistical_draws">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">geostatistical_draws</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">struct_dict</em>, <em class="sig-param">num_reals=100</em>, <em class="sig-param">sigma_range=4</em>, <em class="sig-param">verbose=True</em>, <em class="sig-param">scale_offset=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.geostatistical_draws" title="Permalink to this definition">¶</a></dt>
<dd><p>construct a parameter ensemble from a prior covariance matrix
implied by geostatistical structure(s) and parameter bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file (or the name of control file).  The
parameter bounds in <cite>pst</cite> are used to define the variance of each
parameter group.</p></li>
<li><p><strong>struct_dict</strong> (<cite>dict</cite>) – a dict of GeoStruct (or structure file), and list of
pilot point template files pairs. If the values in the dict are
<cite>pd.DataFrames</cite>, then they must have an ‘x’,’y’, and ‘parnme’ column.
If the filename ends in ‘.csv’, then a pd.DataFrame is loaded,
otherwise a pilot points file is loaded.</p></li>
<li><p><strong>num_reals</strong> (<cite>int</cite>, optional) – number of realizations to draw.  Default is 100</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>) – a float representing the number of standard deviations
implied by parameter bounds. Default is 4.0, which implies 95% confidence parameter bounds.</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>, optional) – flag to control output to stdout.  Default is True.
flag for stdout.</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>,optional) – flag to apply scale and offset to parameter bounds
when calculating variances - this is passed through to <cite>pyemu.Cov.from_parameter_data()</cite>.
Default is True.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns</dt><dd><p><cite>pyemu.ParameterEnsemble</cite>: the realized parameter ensemble.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>parameters are realized by parameter group.  The variance of each
parameter group is used to scale the resulting geostatistical
covariance matrix Therefore, the sill of the geostatistical structures
in <cite>struct_dict</cite> should be 1.0</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">sd</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;struct.dat&quot;</span><span class="p">:[</span><span class="s2">&quot;hkpp.dat.tpl&quot;</span><span class="p">,</span><span class="s2">&quot;vka.dat.tpl&quot;</span><span class="p">]}</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">helpers</span><span class="o">.</span><span class="n">geostatistical_draws</span><span class="p">(</span><span class="n">pst</span><span class="p">,</span><span class="n">struct_dict</span><span class="o">=</span><span class="n">sd</span><span class="p">}</span>
<span class="n">pe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;my_pe.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.geostatistical_prior_builder">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">geostatistical_prior_builder</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">struct_dict</em>, <em class="sig-param">sigma_range=4</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">scale_offset=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.geostatistical_prior_builder" title="Permalink to this definition">¶</a></dt>
<dd><p>construct a full prior covariance matrix using geostastical structures
and parameter bounds information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance (or the name of control file)</p></li>
<li><p><strong>struct_dict</strong> (<cite>dict</cite>) – <p>a dict of GeoStruct (or structure file), and list of
pilot point template files pairs. If the values in the dict are
<cite>pd.DataFrames</cite>, then they must have an ‘x’,’y’, and ‘parnme’ column.</p>
<blockquote>
<div><p>If the filename ends in ‘.csv’, then a pd.DataFrame is loaded,
otherwise a pilot points file is loaded.</p>
</div></blockquote>
</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite>) – a float representing the number of standard deviations
implied by parameter bounds. Default is 4.0, which implies 95% confidence parameter bounds.</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>, optional) – flag to control output to stdout.  Default is True.
flag for stdout.</p></li>
<li><p><strong>scale_offset</strong> (<cite>bool</cite>) – a flag to apply scale and offset to parameter upper and lower bounds
before applying log transform.  Passed to pyemu.Cov.from_parameter_data().  Default
is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a covariance matrix that includes all adjustable parameters in the control
file.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The covariance of parameters associated with geostatistical structures is defined
as a mixture of GeoStruct and bounds.  That is, the GeoStruct is used to construct a
pyemu.Cov, then the entire pyemu.Cov is scaled by the uncertainty implied by the bounds and
sigma_range. Most users will want to sill of the geostruct to sum to 1.0 so that the resulting
covariance matrices have variance proportional to the parameter bounds. Sounds complicated…</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">sd</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;struct.dat&quot;</span><span class="p">:[</span><span class="s2">&quot;hkpp.dat.tpl&quot;</span><span class="p">,</span><span class="s2">&quot;vka.dat.tpl&quot;</span><span class="p">]}</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">helpers</span><span class="o">.</span><span class="n">geostatistical_draws</span><span class="p">(</span><span class="n">pst</span><span class="p">,</span><span class="n">struct_dict</span><span class="o">=</span><span class="n">sd</span><span class="p">}</span>
<span class="n">cov</span><span class="o">.</span><span class="n">to_binary</span><span class="p">(</span><span class="s2">&quot;prior.jcb&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.jco_from_pestpp_runstorage">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">jco_from_pestpp_runstorage</code><span class="sig-paren">(</span><em class="sig-param">rnj_filename</em>, <em class="sig-param">pst_filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.jco_from_pestpp_runstorage" title="Permalink to this definition">¶</a></dt>
<dd><p>read pars and obs from a pest++ serialized run storage
file (e.g., .rnj) and return jacobian matrix instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rnj_filename</strong> (<cite>str</cite>) – the name of the run storage file</p></li>
<li><p><strong>pst_filename</strong> (<cite>str</cite>) – the name of the pst file</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This can then be passed to Jco.to_binary or Jco.to_coo, etc., to write jco
file in a subsequent step to avoid memory resource issues associated
with very large problems.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a jacobian matrix constructed from the run results and
pest control file information.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>pyemu.Jco</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.kl_apply">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">kl_apply</code><span class="sig-paren">(</span><em class="sig-param">par_file</em>, <em class="sig-param">basis_file</em>, <em class="sig-param">par_to_file_dict</em>, <em class="sig-param">arr_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.kl_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a KL parameterization transform from basis factors to model
input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>par_file</strong> (<cite>str</cite>) – the csv file to get factor values from.  Must contain
the following columns: “name”, “new_val”, “org_val”</p></li>
<li><p><strong>basis_file</strong> (<cite>str</cite>) – the PEST-style binary file that contains the reduced
basis</p></li>
<li><p><strong>par_to_file_dict</strong> (<cite>dict</cite>) – a mapping from KL parameter prefixes to array
file names.</p></li>
<li><p><strong>arr_shape</strong> (<em>tuple</em>) – a length 2 tuple of number of rows and columns
the resulting arrays should have.</p></li>
<li><p><strong>Note</strong> – This is the companion function to kl_setup.
This function should be called during the forward run</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.kl_setup">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">kl_setup</code><span class="sig-paren">(</span><em class="sig-param">num_eig</em>, <em class="sig-param">sr</em>, <em class="sig-param">struct</em>, <em class="sig-param">prefixes</em>, <em class="sig-param">factors_file='kl_factors.dat'</em>, <em class="sig-param">islog=True</em>, <em class="sig-param">basis_file=None</em>, <em class="sig-param">tpl_dir='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.kl_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a karhuenen-Loeve based parameterization for a given
geostatistical structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_eig</strong> (<cite>int</cite>) – the number of basis vectors to retain in the
reduced basis</p></li>
<li><p><strong>sr</strong> (<cite>flopy.reference.SpatialReference</cite>) – a spatial reference instance</p></li>
<li><p><strong>struct</strong> (<cite>str</cite>) – a PEST-style structure file.  Can also be a
<cite>pyemu.geostats.Geostruct</cite> instance.</p></li>
<li><p><strong>prefixes</strong> ([<cite>str</cite>]) – a list of parameter prefixes to generate KL
parameterization for.</p></li>
<li><p><strong>factors_file</strong> (<cite>str</cite>, optional) – name of the PEST-style interpolation
factors file to write (can be processed with FAC2REAL).
Default is “kl_factors.dat”.</p></li>
<li><p><strong>islog</strong> (<cite>bool</cite>, optional) – flag to indicate if the parameters are log transformed.
Default is True</p></li>
<li><p><strong>basis_file</strong> (<cite>str</cite>, optional) – the name of the PEST-style binary (e.g. jco)
file to write the reduced basis vectors to.  Default is None (not saved).</p></li>
<li><p><strong>tpl_dir</strong> (<cite>str</cite>, optional) – the directory to write the resulting
template files to.  Default is “.” (current directory).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe of parameter information.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the companion function to <cite>helpers.apply_kl()</cite></p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">flopy</span><span class="o">.</span><span class="n">modflow</span><span class="o">.</span><span class="n">Modflow</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;mymodel.nam&quot;</span><span class="p">)</span>
<span class="n">prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;hk&quot;</span><span class="p">,</span><span class="s2">&quot;vka&quot;</span><span class="p">,</span><span class="s2">&quot;ss&quot;</span><span class="p">]</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">helpers</span><span class="o">.</span><span class="n">kl_setup</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">m</span><span class="o">.</span><span class="n">sr</span><span class="p">,</span><span class="s2">&quot;struct.dat&quot;</span><span class="p">,</span><span class="n">prefixes</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.parse_dir_for_io_files">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">parse_dir_for_io_files</code><span class="sig-paren">(</span><em class="sig-param">d</em>, <em class="sig-param">prepend_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.parse_dir_for_io_files" title="Permalink to this definition">¶</a></dt>
<dd><p>find template/input file pairs and instruction file/output file
pairs by extension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<cite>str</cite>) – directory to search for interface files</p></li>
<li><p><strong>prepend_path</strong> (<a href="#id4"><span class="problematic" id="id5">`</span></a>bool, optional) – flag to prepend <cite>d</cite> to each file name.
Default is False</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the return values from this function can be passed straight to
<cite>pyemu.Pst.from_io_files()</cite> classmethod constructor. Assumes the
template file names are &lt;input_file&gt;.tpl and instruction file names
are &lt;output_file&gt;.ins.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>[`str`]</strong>: list of template files in d</p></li>
<li><p><strong>[`str`]</strong>: list of input files in d</p></li>
<li><p><strong>[`str`]</strong>: list of instruction files in d</p></li>
<li><p><strong>[`str`]</strong>: list of output files in d</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.pst_from_io_files">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">pst_from_io_files</code><span class="sig-paren">(</span><em class="sig-param">tpl_files</em>, <em class="sig-param">in_files</em>, <em class="sig-param">ins_files</em>, <em class="sig-param">out_files</em>, <em class="sig-param">pst_filename=None</em>, <em class="sig-param">pst_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.pst_from_io_files" title="Permalink to this definition">¶</a></dt>
<dd><p>create a Pst instance from model interface files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tpl_files</strong> ([<cite>str</cite>]) – list of template file names</p></li>
<li><p><strong>in_files</strong> ([<cite>str</cite>]) – list of model input file names (pairs with template files)</p></li>
<li><p><strong>ins_files</strong> ([<cite>str</cite>]) – list of instruction file names</p></li>
<li><p><strong>out_files</strong> ([<cite>str</cite>]) – list of model output file names (pairs with instruction files)</p></li>
<li><p><strong>pst_filename</strong> (<cite>str</cite>) – name of control file to write.  If None, no file is written.
Default is None</p></li>
<li><p><strong>pst_path</strong> (<cite>str</cite>) – the path to append to the template_file and in_file in the control file.  If
not None, then any existing path in front of the template or in file is split off
and pst_path is prepended.  If python is being run in a directory other than where the control
file will reside, it is useful to pass <cite>pst_path</cite> as <cite>.</cite>.  Default is None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new control file instance with parameter and observation names
found in <cite>tpl_files</cite> and <cite>ins_files</cite>, repsectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>Pst</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>calls <cite>pyemu.helpers.pst_from_io_files()</cite></p>
<p>Assigns generic values for parameter info.  Tries to use INSCHEK
to set somewhat meaningful observation values</p>
<p>all file paths are relatively to where python is running.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tpl_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;my.tpl&quot;</span><span class="p">]</span>
<span class="n">in_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;my.in&quot;</span><span class="p">]</span>
<span class="n">ins_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;my.ins&quot;</span><span class="p">]</span>
<span class="n">out_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;my.out&quot;</span><span class="p">]</span>
<span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="o">.</span><span class="n">from_io_files</span><span class="p">(</span><span class="n">tpl_files</span><span class="p">,</span><span class="n">in_files</span><span class="p">,</span><span class="n">ins_files</span><span class="p">,</span><span class="n">out_files</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">control_data</span><span class="o">.</span><span class="n">noptmax</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;my.pst)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.pst_from_parnames_obsnames">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">pst_from_parnames_obsnames</code><span class="sig-paren">(</span><em class="sig-param">parnames</em>, <em class="sig-param">obsnames</em>, <em class="sig-param">tplfilename='model.input.tpl'</em>, <em class="sig-param">insfilename='model.output.ins'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.pst_from_parnames_obsnames" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Pst object from a list of parameter names and a list of observation names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parnames</strong> (<cite>str</cite>) – list of parameter names</p></li>
<li><p><strong>obsnames</strong> (<cite>str</cite>) – list of observation names</p></li>
<li><p><strong>tplfilename</strong> (<cite>str</cite>) – template filename. Default is  “model.input.tpl”</p></li>
<li><p><strong>insfilename</strong> (<cite>str</cite>) – instruction filename. Default is “model.output.ins”</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the generic control file</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Pst</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.read_pestpp_runstorage">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">read_pestpp_runstorage</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">irun=0</em>, <em class="sig-param">with_metadata=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.read_pestpp_runstorage" title="Permalink to this definition">¶</a></dt>
<dd><p>read pars and obs from a specific run in a pest++ serialized
run storage file into dataframes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – the name of the run storage file</p></li>
<li><p><strong>irun</strong> (<cite>int</cite>) – the run id to process. If ‘all’, then all runs are
read. Default is 0</p></li>
<li><p><strong>with_metadata</strong> (<cite>bool</cite>) – flag to return run stats and info txt as well</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>pandas.DataFrame</strong>: parameter information</p></li>
<li><p><strong>pandas.DataFrame</strong>: observation information</p></li>
<li><p><strong>pandas.DataFrame</strong>: optionally run status and info txt.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.setup_fake_forward_run">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">setup_fake_forward_run</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">new_pst_name</em>, <em class="sig-param">org_cwd='.'</em>, <em class="sig-param">bak_suffix='._bak'</em>, <em class="sig-param">new_cwd='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.setup_fake_forward_run" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a fake forward run for a pst.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – existing control file</p></li>
<li><p><strong>new_pst_name</strong> (<cite>str</cite>) – new control file to write</p></li>
<li><p><strong>org_cwd</strong> (<cite>str</cite>) – existing working dir.  Default is “.”</p></li>
<li><p><strong>bak_suffix</strong> (<cite>str</cite>, optional) – suffix to add to existing
model output files when making backup copies.</p></li>
<li><p><strong>new_cwd</strong> (<cite>str</cite>) – new working dir.  Default is “.”.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The fake forward run simply copies existing backup versions of
model output files to the outfiles pest(pp) is looking
for.  This is really a development option for debugging
PEST++ issues.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.setup_temporal_diff_obs">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">setup_temporal_diff_obs</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">ins_file</em>, <em class="sig-param">out_file=None</em>, <em class="sig-param">include_zero_weight=False</em>, <em class="sig-param">include_path=False</em>, <em class="sig-param">sort_by_name=True</em>, <em class="sig-param">long_names=True</em>, <em class="sig-param">prefix='dif'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.setup_temporal_diff_obs" title="Permalink to this definition">¶</a></dt>
<dd><p>a helper function to setup difference-in-time observations based on an existing
set of observations in an instruction file using the observation grouping in the
control file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – existing control file</p></li>
<li><p><strong>ins_file</strong> (<cite>str</cite>) – an existing instruction file</p></li>
<li><p><strong>out_file</strong> (<cite>str</cite>, optional) – an existing model output file that corresponds to
the instruction file.  If None, <cite>ins_file.replace(“.ins”,””)</cite> is used</p></li>
<li><p><strong>include_zero_weight</strong> (<cite>bool</cite>, optional) – flag to include zero-weighted observations
in the difference observation process.  Default is False so that only non-zero
weighted observations are used.</p></li>
<li><p><strong>include_path</strong> (<cite>bool</cite>, optional) – flag to setup the binary file processing in directory where the hds_file
is located (if different from where python is running).  This is useful for setting up
the process in separate directory for where python is running.</p></li>
<li><p><strong>sort_by_name</strong> (<cite>bool</cite>,optional) – flag to sort observation names in each group prior to setting up
the differencing.  The order of the observations matters for the differencing.  If False, then
the control file order is used.  If observation names have a datetime suffix, make sure the format is
year-month-day to use this sorting.  Default is True</p></li>
<li><p><strong>long_names</strong> (<cite>bool</cite>, optional) – flag to use long, descriptive names by concating the two observation names
that are being differenced.  This will produce names that are too long for tradtional PEST(_HP).
Default is True.</p></li>
<li><p><strong>prefix</strong> (<cite>str</cite>, optional) – prefix to prepend to observation names and group names.  Default is “dif”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>tuple containing</p>
<ul class="simple">
<li><p><strong>str</strong>: the forward run command to execute the binary file process during model runs.</p></li>
<li><p><strong>pandas.DataFrame</strong>: a dataframe of observation information for use in the pest control file</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this is the companion function of <cite>helpers.apply_temporal_diff_obs()</cite>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.simple_ins_from_obs">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">simple_ins_from_obs</code><span class="sig-paren">(</span><em class="sig-param">obsnames</em>, <em class="sig-param">insfilename='model.output.ins'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.simple_ins_from_obs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>write a simple instruction file that reads the values named</dt><dd><p>in obsnames in order, one per line from a model output file</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obsnames</strong> (<cite>str</cite>) – list of observation names to put in the
new instruction file</p></li>
<li><p><strong>insfilename</strong> (<cite>str</cite>) – the name of the instruction file to
create. Default is “model.output.ins”</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>writes a file <cite>insfilename</cite> with each observation read off
of a single line</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.simple_tpl_from_pars">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">simple_tpl_from_pars</code><span class="sig-paren">(</span><em class="sig-param">parnames</em>, <em class="sig-param">tplfilename='model.input.tpl'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.simple_tpl_from_pars" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a simple template file from a list of parameter names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parnames</strong> ([<cite>str</cite>]) – list of parameter names to put in the
new template file</p></li>
<li><p><strong>tplfilename</strong> (<cite>str</cite>) – Name of the template file to create.  Default
is “model.input.tpl”</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>writes a file <cite>tplfilename</cite> with each parameter name in <cite>parnames</cite> on a line</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.write_const_tpl">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">write_const_tpl</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">tpl_file</em>, <em class="sig-param">suffix</em>, <em class="sig-param">zn_array=None</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">longnames=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.write_const_tpl" title="Permalink to this definition">¶</a></dt>
<dd><p>write a constant (uniform) template file for a 2-D array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<cite>str</cite>) – the base parameter name</p></li>
<li><p><strong>tpl_file</strong> (<cite>str</cite>) – the template file to write</p></li>
<li><p><strong>zn_array</strong> (<cite>numpy.ndarray</cite>, optional) – an array used to skip inactive cells,
and optionally get shape info.</p></li>
<li><p><strong>shape</strong> (<cite>tuple</cite>) – tuple nrow and ncol.  Either <cite>zn_array</cite> or <cite>shape</cite>
must be passed</p></li>
<li><p><strong>longnames</strong> (<cite>bool</cite>) – flag to use longer names that exceed 12 chars in length.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with parameter information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.write_grid_tpl">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">write_grid_tpl</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">tpl_file</em>, <em class="sig-param">suffix</em>, <em class="sig-param">zn_array=None</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">spatial_reference=None</em>, <em class="sig-param">longnames=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.write_grid_tpl" title="Permalink to this definition">¶</a></dt>
<dd><p>write a grid-based template file for a 2-D array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<cite>str</cite>) – the base parameter name</p></li>
<li><p><strong>tpl_file</strong> (<cite>str</cite>) – the template file to write - include path</p></li>
<li><p><strong>zn_array</strong> (<cite>numpy.ndarray</cite>, optional) – zone array to identify
inactive cells.  Default is None</p></li>
<li><p><strong>shape</strong> (<cite>tuple</cite>, optional) – a length-two tuple of nrow and ncol.  Either
<cite>zn_array</cite> or <cite>shape</cite> must be passed.</p></li>
<li><p><strong>spatial_reference</strong> (<cite>flopy.utils.SpatialReference</cite>) – a spatial reference instance.
If <cite>longnames</cite> is True, then <cite>spatial_reference</cite> is used to add spatial info
to the parameter names.</p></li>
<li><p><strong>longnames</strong> (<cite>bool</cite>) – flag to use longer names that exceed 12 chars in length.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with parameter information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.write_zone_tpl">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">write_zone_tpl</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">tpl_file</em>, <em class="sig-param">suffix=''</em>, <em class="sig-param">zn_array=None</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">longnames=False</em>, <em class="sig-param">fill_value='1.0'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.write_zone_tpl" title="Permalink to this definition">¶</a></dt>
<dd><p>write a zone-based template file for a 2-D array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<cite>str</cite>) – the base parameter name</p></li>
<li><p><strong>tpl_file</strong> (<cite>str</cite>) – the template file to write</p></li>
<li><p><strong>suffix</strong> (<cite>str</cite>) – suffix to add to parameter names.  Only used if <cite>longnames=True</cite></p></li>
<li><p><strong>zn_array</strong> (<cite>numpy.ndarray</cite>, optional) – an array used to skip inactive cells,
and optionally get shape info.  zn_array values less than 1 are given <cite>fill_value</cite></p></li>
<li><p><strong>shape</strong> (<cite>tuple</cite>) – tuple nrow and ncol.  Either <cite>zn_array</cite> or <cite>shape</cite>
must be passed</p></li>
<li><p><strong>longnames</strong> (<cite>bool</cite>) – flag to use longer names that exceed 12 chars in length.
Default is False.</p></li>
<li><p><strong>fill_value</strong> (<cite>str</cite>) – value to fill locations where <cite>zn_array</cite> is less than 1.0.
Default is “1.0”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with parameter information</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.helpers.zero_order_tikhonov">
<code class="sig-prename descclassname">pyemu.utils.helpers.</code><code class="sig-name descname">zero_order_tikhonov</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">parbounds=True</em>, <em class="sig-param">par_groups=None</em>, <em class="sig-param">reset=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.helpers.zero_order_tikhonov" title="Permalink to this definition">¶</a></dt>
<dd><p>setup preferred-value regularization in a pest control file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – the control file instance</p></li>
<li><p><strong>parbounds</strong> (<cite>bool</cite>, optional) – flag to weight the new prior information
equations according to parameter bound width - approx the KL
transform. Default is True</p></li>
<li><p><strong>par_groups</strong> (<cite>list</cite>) – a list of parameter groups to build PI equations for.
If None, all adjustable parameters are used. Default is None</p></li>
<li><p><strong>reset</strong> (<cite>bool</cite>) – a flag to remove any existing prior information equations
in the control file.  Default is True</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">helpers</span><span class="o">.</span><span class="n">zero_order_tikhonov</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">pst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;my_reg.pst&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-pyemu.utils.pp_utils"></span><p>Pilot point support utilities</p>
<dl class="function">
<dt id="pyemu.utils.pp_utils.pilot_points_to_tpl">
<code class="sig-prename descclassname">pyemu.utils.pp_utils.</code><code class="sig-name descname">pilot_points_to_tpl</code><span class="sig-paren">(</span><em class="sig-param">pp_file</em>, <em class="sig-param">tpl_file=None</em>, <em class="sig-param">name_prefix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.pp_utils.pilot_points_to_tpl" title="Permalink to this definition">¶</a></dt>
<dd><p>write a template file for a pilot points file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pp_file</strong> – (<cite>str</cite>): existing pilot points file</p></li>
<li><p><strong>tpl_file</strong> (<cite>str</cite>) – template file name to write.  If None,
<cite>pp_file`+”.tpl” is used.  Default is `None</cite>.</p></li>
<li><p><strong>name_prefix</strong> (<cite>str</cite>) – name to prepend to parameter names for each
pilot point.  For example, if <cite>name_prefix = “hk_”</cite>, then each
pilot point parameters will be named “hk_0001”,”hk_0002”, etc.
If None, parameter names from <cite>pp_df.name</cite> are used.
Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with pilot point information
(name,x,y,zone,parval1) with the parameter information
(parnme,tpl_str)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.pp_utils.pp_file_to_dataframe">
<code class="sig-prename descclassname">pyemu.utils.pp_utils.</code><code class="sig-name descname">pp_file_to_dataframe</code><span class="sig-paren">(</span><em class="sig-param">pp_filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.pp_utils.pp_file_to_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>read a pilot point file to a pandas Dataframe</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pp_filename</strong> (<cite>str</cite>) – path and name of an existing pilot point file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with <cite>pp_utils.PP_NAMES</cite> for columns</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">pp_utils</span><span class="o">.</span><span class="n">pp_file_to_dataframe</span><span class="p">(</span><span class="s2">&quot;my_pp.dat&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.pp_utils.pp_tpl_to_dataframe">
<code class="sig-prename descclassname">pyemu.utils.pp_utils.</code><code class="sig-name descname">pp_tpl_to_dataframe</code><span class="sig-paren">(</span><em class="sig-param">tpl_filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.pp_utils.pp_tpl_to_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>read a pilot points template file to a pandas dataframe</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tpl_filename</strong> (<cite>str</cite>) – path and name of an existing pilot points
template file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe of pilot point info with “parnme” included</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Use for processing pilot points since the point point file itself may
have generic “names”.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">pp_utils</span><span class="o">.</span><span class="n">pp_tpl_file_to_dataframe</span><span class="p">(</span><span class="s2">&quot;my_pp.dat.tpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.pp_utils.setup_pilotpoints_grid">
<code class="sig-prename descclassname">pyemu.utils.pp_utils.</code><code class="sig-name descname">setup_pilotpoints_grid</code><span class="sig-paren">(</span><em class="sig-param">ml=None</em>, <em class="sig-param">sr=None</em>, <em class="sig-param">ibound=None</em>, <em class="sig-param">prefix_dict=None</em>, <em class="sig-param">every_n_cell=4</em>, <em class="sig-param">use_ibound_zones=False</em>, <em class="sig-param">pp_dir='.'</em>, <em class="sig-param">tpl_dir='.'</em>, <em class="sig-param">shapename='pp.shp'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.pp_utils.setup_pilotpoints_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a regularly-spaced (gridded) pilot point parameterization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ml</strong> (<cite>flopy.mbase</cite>, optional) – a flopy mbase dervied type.  If None, <cite>sr</cite> must not be None.</p></li>
<li><p><strong>sr</strong> (<cite>flopy.utils.reference.SpatialReference</cite>, optional) – a spatial reference use to
locate the model grid in space.  If None, <cite>ml</cite> must not be None.  Default is None</p></li>
<li><p><strong>ibound</strong> (<cite>numpy.ndarray</cite>, optional) – the modflow ibound integer array.  THis is used to
set pilot points only in active areas. If None and ml is None, then pilot points
are set in all rows and columns according to <cite>every_n_cell</cite>.  Default is None.</p></li>
<li><p><strong>prefix_dict</strong> (<cite>dict</cite>) – a dictionary of layer index, pilot point parameter prefix(es) pairs.
For example : <cite>{0:[“hk,”vk”]}</cite> would setup pilot points with the prefix “hk” and “vk” for
model layer 1. If None, a generic set of pilot points with
the “pp” prefix are setup for a generic nrow by ncol grid. Default is None</p></li>
<li><p><strong>use_ibound_zones</strong> (<cite>bool</cite>) – a flag to use the greater-than-zero values in the
ibound as pilot point zones.  If False ,ibound values greater than zero are
treated as a single zone.  Default is False.</p></li>
<li><p><strong>pp_dir</strong> (<cite>str</cite>, optional) – directory to write pilot point files to.  Default is ‘.’</p></li>
<li><p><strong>tpl_dir</strong> (<cite>str</cite>, optional) – directory to write pilot point template file to.  Default is ‘.’</p></li>
<li><p><strong>shapename</strong> (<cite>str</cite>, optional) – name of shapefile to write that contains pilot
point information. Default is “pp.shp”</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe summarizing pilot point information (same information
written to <cite>shapename</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">flopy</span><span class="o">.</span><span class="n">modflow</span><span class="o">.</span><span class="n">Modflow</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;my.nam&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">pp_utils</span><span class="o">.</span><span class="n">setup_pilotpoints_grid</span><span class="p">(</span><span class="n">ml</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.pp_utils.write_pp_file">
<code class="sig-prename descclassname">pyemu.utils.pp_utils.</code><code class="sig-name descname">write_pp_file</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">pp_df</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.pp_utils.write_pp_file" title="Permalink to this definition">¶</a></dt>
<dd><p>write a pilot points dataframe to a pilot points file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – pilot points file to write</p></li>
<li><p><strong>pp_df</strong> (<cite>pandas.DataFrame</cite>) – a dataframe that has
at least columns “x”,”y”,”zone”, and “value”</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.pp_utils.write_pp_shapfile">
<code class="sig-prename descclassname">pyemu.utils.pp_utils.</code><code class="sig-name descname">write_pp_shapfile</code><span class="sig-paren">(</span><em class="sig-param">pp_df</em>, <em class="sig-param">shapename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.pp_utils.write_pp_shapfile" title="Permalink to this definition">¶</a></dt>
<dd><p>write pilot points dataframe to a shapefile</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pp_df</strong> (<cite>pandas.DataFrame</cite>) – pilot point dataframe (must include “x” and “y”
columns).  If <cite>pp_df</cite> is a string, it is assumed to be a pilot points file
and is loaded with <cite>pp_utils.pp_file_to_dataframe</cite>. Can also be a list of
<cite>pandas.DataFrames</cite> and/or filenames.</p></li>
<li><p><strong>shapename</strong> (<cite>str</cite>) – the shapefile name to write.  If <cite>None</cite> , <cite>pp_df</cite> must be a string
and shapefile is saved as <cite>pp_df</cite> +”.shp”</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>requires pyshp</p>
</dd></dl>

<span class="target" id="module-pyemu.utils.os_utils"></span><p>Operating system utilities in the PEST(++) realm</p>
<dl class="function">
<dt id="pyemu.utils.os_utils.run">
<code class="sig-prename descclassname">pyemu.utils.os_utils.</code><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">cmd_str</em>, <em class="sig-param">cwd='.'</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.os_utils.run" title="Permalink to this definition">¶</a></dt>
<dd><p>an OS agnostic function to execute a command line</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cmd_str</strong> (<cite>str</cite>) – the str to execute with <cite>os.system()</cite></p></li>
<li><p><strong>cwd</strong> (<cite>str</cite>, optional) – the directory to execute the command in.
Default is “.”.</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>, optional) – flag to echo to stdout the  <cite>cmd_str</cite>.
Default is <cite>False</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>uses <cite>platform</cite> to detect OS and adds .exe suffix or ./ prefix as appropriate
if <cite>os.system</cite> returns non-zero, an exception is raised</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyemu</span><span class="o">.</span><span class="n">os_utils</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s2">&quot;pestpp-ies my.pst&quot;</span><span class="p">,</span><span class="n">cwd</span><span class="o">=</span><span class="s2">&quot;template&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.os_utils.start_workers">
<code class="sig-prename descclassname">pyemu.utils.os_utils.</code><code class="sig-name descname">start_workers</code><span class="sig-paren">(</span><em class="sig-param">worker_dir</em>, <em class="sig-param">exe_rel_path</em>, <em class="sig-param">pst_rel_path</em>, <em class="sig-param">num_workers=None</em>, <em class="sig-param">worker_root='..'</em>, <em class="sig-param">port=4004</em>, <em class="sig-param">rel_path=None</em>, <em class="sig-param">local=True</em>, <em class="sig-param">cleanup=True</em>, <em class="sig-param">master_dir=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">silent_master=False</em>, <em class="sig-param">reuse_master=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.os_utils.start_workers" title="Permalink to this definition">¶</a></dt>
<dd><p>start a group of pest(++) workers on the local machine</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>worker_dir</strong> (<cite>str</cite>) – the path to a complete set of input files need by PEST(++).
This directory will be copied to make worker (and optionally the master)
directories</p></li>
<li><p><strong>exe_rel_path</strong> (<cite>str</cite>) – the relative path to and name of the pest(++) executable from within
the <cite>worker_dir</cite>.  For example, if the executable is up one directory from
<cite>worker_dir</cite>, the <cite>exe_rel_path</cite> would be <cite>os.path.join(“..”,”pestpp-ies”)</cite></p></li>
<li><p><strong>pst_rel_path</strong> (<cite>str</cite>) – the relative path to and name of the pest control file from within
<cite>worker_dir</cite>.</p></li>
<li><p><strong>num_workers</strong> (<cite>int</cite>, optional) – number of workers to start. defaults to number of cores</p></li>
<li><p><strong>worker_root</strong> (<cite>str</cite>, optional) – the root directory to make the new worker directories in.
Default is “..”  (up one directory from where python is running).</p></li>
<li><p><strong>rel_path</strong> (<cite>str</cite>, optional) – the relative path to where pest(++) should be run
from within the worker_dir, defaults to the uppermost level of the worker dir.
This option is usually not needed unless you are one of those crazy people who
spreads files across countless subdirectories.</p></li>
<li><p><strong>local</strong> (<cite>bool</cite>, optional) – flag for using “localhost” instead of actual hostname/IP address on
worker command line. Default is True</p></li>
<li><p><strong>cleanup</strong> (<cite>bool</cite>, optional) – flag to remove worker directories once processes exit. Default is
True.  Set to False for debugging issues</p></li>
<li><p><strong>master_dir</strong> (<cite>str</cite>) – name of directory for master instance.  If <cite>master_dir</cite>
exists, then it will be REMOVED!!!  If <cite>master_dir</cite>, is None,
no master instance will be started.  If not None, a copy of <cite>worker_dir</cite> will be
made into <cite>master_dir</cite> and the PEST(++) executable will be started in master mode
in this directory. Default is None</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>, optional) – flag to echo useful information to stdout.  Default is False</p></li>
<li><p><strong>silent_master</strong> (<cite>bool</cite>, optional) – flag to pipe master output to devnull and instead print
a simple message to stdout every few seconds.  This is only for
pestpp Travis testing so that log file sizes dont explode. Default is False</p></li>
<li><p><strong>reuse_master</strong> (<cite>bool</cite>) – flag to use an existing <cite>master_dir</cite> as is - this is an advanced user
option for cases where you want to construct your own <cite>master_dir</cite> then have an async
process started in it by this function.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>if all workers (and optionally master) exit gracefully, then the worker</dt><dd><p>dirs will be removed unless <cite>cleanup</cite> is False</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># start 10 workers using the directory &quot;template&quot; as the base case and</span>
<span class="c1"># also start a master instance in a directory &quot;master&quot;.</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">helpers</span><span class="o">.</span><span class="n">start_workers</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span><span class="s2">&quot;pestpp-ies&quot;</span><span class="p">,</span><span class="s2">&quot;pest.pst&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">master_dir</span><span class="o">=</span><span class="s2">&quot;master&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-pyemu.utils.geostats"></span><p>Geostatistics in the PEST(++) realm</p>
<dl class="class">
<dt id="pyemu.utils.geostats.ExpVario">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">ExpVario</code><span class="sig-paren">(</span><em class="sig-param">contribution</em>, <em class="sig-param">a</em>, <em class="sig-param">anisotropy=1.0</em>, <em class="sig-param">bearing=0.0</em>, <em class="sig-param">name='var1'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.ExpVario" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian variogram derived type</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contribution</strong> (<em>float</em>) – sill of the variogram</p></li>
<li><p><strong>a</strong> (<cite>float</cite>) – (practical) range of correlation</p></li>
<li><p><strong>anisotropy</strong> (<cite>float</cite>, optional) – Anisotropy ratio. Default is 1.0</p></li>
<li><p><strong>bearing</strong> – (<cite>float</cite>, optional): angle in degrees East of North corresponding
to anisotropy ellipse. Default is 0.0</p></li>
<li><p><strong>name</strong> (<cite>str</cite>, optinoal) – name of the variogram.  Default is “var1”</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">ExpVario</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">contribution</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="pyemu.utils.geostats.GauVario">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">GauVario</code><span class="sig-paren">(</span><em class="sig-param">contribution</em>, <em class="sig-param">a</em>, <em class="sig-param">anisotropy=1.0</em>, <em class="sig-param">bearing=0.0</em>, <em class="sig-param">name='var1'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.GauVario" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian variogram derived type</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contribution</strong> (<em>float</em>) – sill of the variogram</p></li>
<li><p><strong>a</strong> (<cite>float</cite>) – (practical) range of correlation</p></li>
<li><p><strong>anisotropy</strong> (<cite>float</cite>, optional) – Anisotropy ratio. Default is 1.0</p></li>
<li><p><strong>bearing</strong> – (<cite>float</cite>, optional): angle in degrees East of North corresponding
to anisotropy ellipse. Default is 0.0</p></li>
<li><p><strong>name</strong> (<cite>str</cite>, optinoal) – name of the variogram.  Default is “var1”</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">GauVario</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">contribution</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the Gaussian variogram can be unstable (not invertible) for long ranges.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="pyemu.utils.geostats.GeoStruct">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">GeoStruct</code><span class="sig-paren">(</span><em class="sig-param">nugget=0.0</em>, <em class="sig-param">variograms=[]</em>, <em class="sig-param">name='struct1'</em>, <em class="sig-param">transform='none'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct" title="Permalink to this definition">¶</a></dt>
<dd><p>a geostatistical structure object that mimics the behavior of a PEST
geostatistical structure.  The object contains variogram instances and
(optionally) nugget information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nugget</strong> (<cite>float</cite> (optional)) – nugget contribution. Default is 0.0</p></li>
<li><p><strong>variograms</strong> – ([<cite>pyemu.Vario2d</cite>] (optional)): variogram(s) associated
with this GeoStruct instance. Default is empty list</p></li>
<li><p><strong>name</strong> (<cite>str</cite> (optional)) – name to assign the structure.  Default
is “struct1”.</p></li>
<li><p><strong>transform</strong> (<cite>str</cite> (optional)) – the transformation to apply to
the GeoStruct.  Can be “none” or “log”, depending on the
transformation of the property being represented by the <cite>GeoStruct</cite>.
Default is “none”</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">ExpVario</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">contribution</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">GeoStruct</span><span class="p">(</span><span class="n">variograms</span><span class="o">=</span><span class="n">v</span><span class="p">,</span><span class="n">nugget</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.utils.geostats.GeoStruct.covariance">
<code class="sig-name descname">covariance</code><span class="sig-paren">(</span><em class="sig-param">pt0</em>, <em class="sig-param">pt1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>get the covariance between two points implied by the <cite>GeoStruct</cite>.
This is used during the ordinary kriging process to get the RHS</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pt0</strong> ([<cite>float</cite>]) – xy-pair</p></li>
<li><p><strong>pt1</strong> ([<cite>float</cite>]) – xy-pair</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the covariance between pt0 and pt1 implied
by the GeoStruct</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.GeoStruct.covariance_matrix">
<code class="sig-name descname">covariance_matrix</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">names=None</em>, <em class="sig-param">cov=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>build a <cite>pyemu.Cov</cite> instance from <cite>GeoStruct</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> ([<cite>floats</cite>]) – x-coordinate locations</p></li>
<li><p><strong>y</strong> ([<cite>float</cite>]) – y-coordinate locations</p></li>
<li><p><strong>names</strong> ([<cite>str</cite>] (optional)) – names of location. If None,
cov must not be None.  Default is None.</p></li>
<li><p><strong>cov</strong> (<cite>pyemu.Cov</cite>) – an existing Cov instance.  The contribution
of this GeoStruct is added to cov.  If cov is None,
names must not be None. Default is None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the covariance matrix implied by this
GeoStruct for the x,y pairs. <cite>cov</cite> has row and column
names supplied by the names argument unless the “cov”
argument was passed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>either “names” or “cov” must be passed.  If “cov” is passed, cov.shape
must equal len(x) and len(y).</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pp_df</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">pp_utils</span><span class="o">.</span><span class="n">pp_file_to_dataframe</span><span class="p">(</span><span class="s2">&quot;hkpp.dat&quot;</span><span class="p">)</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">(</span><span class="n">pp_df</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">pp_df</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">pp_df</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="n">cov</span><span class="o">.</span><span class="n">to_binary</span><span class="p">(</span><span class="s2">&quot;cov.jcb&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.GeoStruct.covariance_points">
<code class="sig-name descname">covariance_points</code><span class="sig-paren">(</span><em class="sig-param">x0</em>, <em class="sig-param">y0</em>, <em class="sig-param">xother</em>, <em class="sig-param">yother</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.covariance_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the covariance between point (x0,y0) and the points
contained in xother, yother.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<cite>float</cite>) – x-coordinate</p></li>
<li><p><strong>y0</strong> (<cite>float</cite>) – y-coordinate</p></li>
<li><p><strong>xother</strong> ([<cite>float</cite>]) – x-coordinates of other points</p></li>
<li><p><strong>yother</strong> ([<cite>float</cite>]) – y-coordinates of other points</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a 1-D array of covariance between point x0,y0 and the
points contained in xother, yother.  len(cov) = len(xother) =
len(yother)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.utils.geostats.GeoStruct.nugget">
<code class="sig-name descname">nugget</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.nugget" title="Permalink to this definition">¶</a></dt>
<dd><p>the nugget effect contribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.GeoStruct.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>make a cheap plot of the <cite>GeoStruct</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – (dict)
keyword arguments to use for plotting.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the axis with the GeoStruct plot</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>matplotlib.pyplot.axis</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>optional arguments include “ax” (an existing axis),
“individuals” (plot each variogram on a separate axis),
“legend” (add a legend to the plot(s)).  All other kwargs
are passed to matplotlib.pyplot.plot()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.GeoStruct.sill">
<em class="property">property </em><code class="sig-name descname">sill</code><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.sill" title="Permalink to this definition">¶</a></dt>
<dd><p>get the sill of the <cite>GeoStruct</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the sill of the (nested) <cite>GeoStruct</cite>, including
nugget and contribution from each variogram</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.GeoStruct.to_struct_file">
<code class="sig-name descname">to_struct_file</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.to_struct_file" title="Permalink to this definition">¶</a></dt>
<dd><p>write a PEST-style structure file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<cite>str</cite>) – file to write the GeoStruct information in to.  Can
also be an open file handle</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.utils.geostats.GeoStruct.transform">
<code class="sig-name descname">transform</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>the transformation of the <cite>GeoStruct</cite>.  Can be ‘log’ or ‘none’</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><cite>str</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyemu.utils.geostats.GeoStruct.variograms">
<code class="sig-name descname">variograms</code><em class="property"> = None</em><a class="headerlink" href="#pyemu.utils.geostats.GeoStruct.variograms" title="Permalink to this definition">¶</a></dt>
<dd><p>a list of variogram instances</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>[<cite>pyemu.utils.geostats.Vario2d</cite>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyemu.utils.geostats.OrdinaryKrige">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">OrdinaryKrige</code><span class="sig-paren">(</span><em class="sig-param">geostruct</em>, <em class="sig-param">point_data</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.OrdinaryKrige" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordinary Kriging using Pandas and Numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geostruct</strong> (<cite>GeoStruct</cite>) – a pyemu.geostats.GeoStruct to use for the kriging</p></li>
<li><p><strong>point_data</strong> (<cite>pandas.DataFrame</cite>) – the conditioning points to use for kriging.
<cite>point_data</cite> must contain columns “name”, “x”, “y”.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if <cite>point_data</cite> is an <cite>str</cite>, then it is assumed to be a pilot points file
and is loaded as such using <cite>pyemu.pp_utils.pp_file_to_dataframe()</cite></p>
<p>If zoned interpolation is used for grid-based interpolation, then
<cite>point_data</cite> must also contain a “zone” column</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyemu</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">ExpVario</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">contribution</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">GeoStruct</span><span class="p">(</span><span class="n">variograms</span><span class="o">=</span><span class="n">v</span><span class="p">,</span><span class="n">nugget</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">pp_df</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">pp_utils</span><span class="o">.</span><span class="n">pp_file_to_dataframe</span><span class="p">(</span><span class="s2">&quot;hkpp.dat&quot;</span><span class="p">)</span>
<span class="n">ok</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">OrdinaryKrige</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span><span class="n">pp_df</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.utils.geostats.OrdinaryKrige.calc_factors">
<code class="sig-name descname">calc_factors</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">minpts_interp=1</em>, <em class="sig-param">maxpts_interp=20</em>, <em class="sig-param">search_radius=10000000000.0</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">pt_zone=None</em>, <em class="sig-param">forgive=False</em>, <em class="sig-param">num_threads=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.OrdinaryKrige.calc_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate ordinary kriging factors (weights) for the points
represented by arguments x and y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> ([<cite>float</cite>]) – x-coordinates to calculate kriging factors for</p></li>
<li><p><strong>y</strong> (([<cite>float</cite>]) – y-coordinates to calculate kriging factors for</p></li>
<li><p><strong>minpts_interp</strong> (<cite>int</cite>) – minimum number of point_data entires to use for interpolation at
a given x,y interplation point.  interpolation points with less
than <cite>minpts_interp</cite> <cite>point_data</cite> found will be skipped
(assigned np.NaN).  Defaut is 1</p></li>
<li><p><strong>maxpts_interp</strong> (<cite>int</cite>) – maximum number of point_data entries to use for interpolation at
a given x,y interpolation point.  A larger <cite>maxpts_interp</cite> will
yield “smoother” interplation, but using a large <cite>maxpts_interp</cite>
will slow the (already) slow kriging solution process and may
lead to memory errors. Default is 20.</p></li>
<li><p><strong>search_radius</strong> (<cite>float</cite>) – the size of the region around a given x,y
interpolation point to search for <cite>point_data</cite> entries. Default is 1.0e+10</p></li>
<li><p><strong>verbose</strong> (<cite>bool</cite>) – a flag to  echo process to stdout during the interpolatino process.
Default is False</p></li>
<li><p><strong>forgive</strong> (<cite>bool</cite>) – flag to continue if inversion of the kriging matrix failes at one or more
interpolation points.  Inversion usually fails if the kriging matrix is singular,
resulting from <cite>point_data</cite> entries closer than EPSILON distance.  If True,
warnings are issued for each failed inversion.  If False, an exception
is raised for failed matrix inversion.</p></li>
<li><p><strong>num_threads</strong> (<cite>int</cite>) – number of multiprocessing workers to use to try to speed up
kriging in python.  Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with information summarizing the ordinary kriging
process for each interpolation points</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this method calls either <cite>OrdinaryKrige.calc_factors_org()</cite> or
<cite>OrdinaryKrige.calc_factors_mp()</cite> depending on the value of <cite>num_threads</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.OrdinaryKrige.calc_factors_grid">
<code class="sig-name descname">calc_factors_grid</code><span class="sig-paren">(</span><em class="sig-param">spatial_reference</em>, <em class="sig-param">zone_array=None</em>, <em class="sig-param">minpts_interp=1</em>, <em class="sig-param">maxpts_interp=20</em>, <em class="sig-param">search_radius=10000000000.0</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">var_filename=None</em>, <em class="sig-param">forgive=False</em>, <em class="sig-param">num_threads=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.OrdinaryKrige.calc_factors_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate kriging factors (weights) for a structured grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spatial_reference</strong> (<cite>flopy.utils.reference.SpatialReference</cite>) – a spatial
reference that describes the orientation and
spatail projection of the the structured grid</p></li>
<li><p><strong>zone_array</strong> (<cite>numpy.ndarray</cite>) – an integer array of zones to use for kriging.
If not None, then <cite>point_data</cite> must also contain a “zone” column.  <cite>point_data</cite>
entries with a zone value not found in zone_array will be skipped.
If None, then all <cite>point_data</cite> will (potentially) be used for
interpolating each grid node. Default is None</p></li>
<li><p><strong>minpts_interp</strong> (<cite>int</cite>) – minimum number of <cite>point_data</cite> entires to use for interpolation at
a given grid node.  grid nodes with less than <cite>minpts_interp</cite>
<cite>point_data</cite> found will be skipped (assigned np.NaN).  Defaut is 1</p></li>
<li><p><strong>maxpts_interp</strong> (<cite>int</cite>) – a given grid node.  A larger <cite>maxpts_interp</cite> will yield “smoother”
interplation, but using a large <cite>maxpts_interp</cite> will slow the
(already) slow kriging solution process and may lead to
memory errors. Default is 20.</p></li>
<li><p><strong>search_radius</strong> (<cite>float</cite>) – <cite>point_data</cite> entries. Default is 1.0e+10</p></li>
<li><p><strong>verbose</strong> – (<cite>bool</cite>): a flag to  echo process to stdout during the interpolatino process.
Default is False</p></li>
<li><p><strong>var_filename</strong> (<cite>str</cite>) – a filename to save the kriging variance for each interpolated grid node.
Default is None.</p></li>
<li><p><strong>forgive</strong> (<cite>bool</cite>) – flag to continue if inversion of the kriging matrix failes at one or more
grid nodes.  Inversion usually fails if the kriging matrix is singular,
resulting from <cite>point_data</cite> entries closer than EPSILON distance.  If True,
warnings are issued for each failed inversion.  If False, an exception
is raised for failed matrix inversion.</p></li>
<li><p><strong>num_threads</strong> (<cite>int</cite>) – number of multiprocessing workers to use to try to speed up
kriging in python.  Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe with information summarizing the ordinary kriging
process for each grid node</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this method calls OrdinaryKrige.calc_factors()</p>
<p>this method is the main entry point for grid-based kriging factor generation</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">flopy</span>

<span class="kn">import</span> <span class="nn">pyemu</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">ExpVario</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">contribution</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">GeoStruct</span><span class="p">(</span><span class="n">variograms</span><span class="o">=</span><span class="n">v</span><span class="p">,</span><span class="n">nugget</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">pp_df</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">pp_utils</span><span class="o">.</span><span class="n">pp_file_to_dataframe</span><span class="p">(</span><span class="s2">&quot;hkpp.dat&quot;</span><span class="p">)</span>
<span class="n">ok</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">OrdinaryKrige</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span><span class="n">pp_df</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">flopy</span><span class="o">.</span><span class="n">modflow</span><span class="o">.</span><span class="n">Modflow</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;mymodel.nam&quot;</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">ok</span><span class="o">.</span><span class="n">calc_factors_grid</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">sr</span><span class="p">,</span><span class="n">zone_array</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">bas6</span><span class="o">.</span><span class="n">ibound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                          <span class="n">var_filename</span><span class="o">=</span><span class="s2">&quot;ok_var.dat&quot;</span><span class="p">)</span>
<span class="n">ok</span><span class="o">.</span><span class="n">to_grid_factor_file</span><span class="p">(</span><span class="s2">&quot;factors.dat&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.OrdinaryKrige.check_point_data_dist">
<code class="sig-name descname">check_point_data_dist</code><span class="sig-paren">(</span><em class="sig-param">rectify=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.OrdinaryKrige.check_point_data_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>check for point_data entries that are closer than
EPSILON distance - this will cause a singular kriging matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rectify</strong> (<cite>bool</cite>) – flag to fix the problems with point_data
by dropping additional points that are
closer than EPSILON distance.  Default is False</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this method will issue warnings for points that are closer
than EPSILON distance</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.OrdinaryKrige.to_grid_factors_file">
<code class="sig-name descname">to_grid_factors_file</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">points_file='points.junk'</em>, <em class="sig-param">zone_file='zone.junk'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.OrdinaryKrige.to_grid_factors_file" title="Permalink to this definition">¶</a></dt>
<dd><p>write a grid-based PEST-style factors file.  This file can be used with
the fac2real() method to write an interpolated structured array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – factor filename</p></li>
<li><p><strong>points_file</strong> (<cite>str</cite>) – points filename to add to the header of the factors file.
This is not used by the fac2real() method.  Default is “points.junk”</p></li>
<li><p><strong>zone_file</strong> (<cite>str</cite>) – zone filename to add to the header of the factors file.
This is notused by the fac2real() method.  Default is “zone.junk”</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this method should be called after OrdinaryKirge.calc_factors_grid()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyemu.utils.geostats.SpecSim2d">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">SpecSim2d</code><span class="sig-paren">(</span><em class="sig-param">delx</em>, <em class="sig-param">dely</em>, <em class="sig-param">geostruct</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.SpecSim2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2-D unconditional spectral simulation for regular grids</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delx</strong> (<cite>numpy.ndarray</cite>) – a 1-D array of x-dimension cell centers
(or leading/trailing edges).  Only the distance between points
is important</p></li>
<li><p><strong>dely</strong> (<cite>numpy.ndarray</cite>) – a 1-D array of y-dimension cell centers
(or leading/trailing edges).  Only the distance between points
is important</p></li>
<li><p><strong>geostruct</strong> (<cite>pyemu.geostats.Geostruct</cite>) – geostatistical structure instance</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">ExpVario</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">contribution</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">GeoStruct</span><span class="p">(</span><span class="n">variograms</span><span class="o">=</span><span class="n">v</span><span class="p">,</span><span class="n">nugget</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">delx</span><span class="p">,</span><span class="n">dely</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arrange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">ss</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">SpecSim2d</span><span class="p">(</span><span class="n">delx</span><span class="p">,</span><span class="n">dely</span><span class="p">,</span><span class="n">gs</span><span class="p">)</span>
<span class="n">arrays</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">num_reals</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyemu.utils.geostats.SpecSim2d.draw_arrays">
<code class="sig-name descname">draw_arrays</code><span class="sig-paren">(</span><em class="sig-param">num_reals=1</em>, <em class="sig-param">mean_value=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.SpecSim2d.draw_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>draw realizations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_reals</strong> (<cite>int</cite>) – number of realizations to generate</p></li>
<li><p><strong>mean_value</strong> (<cite>float</cite>) – the mean value of the realizations</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a 3-D array of realizations.  Shape
is (num_reals,self.dely.shape[0],self.delx.shape[0])</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>log transformation is respected and the returned <cite>reals</cite> array is
in arithmatic space</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.SpecSim2d.draw_conditional">
<code class="sig-name descname">draw_conditional</code><span class="sig-paren">(</span><em class="sig-param">seed</em>, <em class="sig-param">obs_points</em>, <em class="sig-param">sg</em>, <em class="sig-param">base_values_file</em>, <em class="sig-param">local=True</em>, <em class="sig-param">factors_file=None</em>, <em class="sig-param">num_reals=1</em>, <em class="sig-param">mean_value=1.0</em>, <em class="sig-param">R_factor=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.SpecSim2d.draw_conditional" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Generate a conditional, correlated random field using the Spec2dSim</dt><dd><p>object, a set of observation points, and a factors file.</p>
<p>The conditional field is made by generating an unconditional correlated random
field that captures the covariance in the variogram and conditioning it by kriging
a second surface using the value of the random field as observations.
This second conditioning surface provides an estimate of uncertainty (kriging error)
away from the observation points. At the observation points, the kriged surface is
equal to (less nugget effects) the observation. The conditioned correlated field
is then generated using:</p>
<blockquote>
<div><p>T(x) = Z(x) + [S(x) − S∗(x)]</p>
</div></blockquote>
<p>where T(x) is the conditioned simulation, Z(x) is a kriging estimator of the
unknown field, S(x) is an unconditioned random field with the same covariance
structure as the desired field, and S∗(x) is a kriging estimate of the unconditioned
random field using its values at the observation points (pilot points).
[S(x) − S∗(x)] is an estimate of the kriging error.</p>
<p>This approach makes T(x) match the observed values at the observation points
(x_a, y_z), T(a) = Z(a), and have a structure away from the observation points that
follows the variogram used to generate Z, S, and S∗.</p>
<dl class="simple">
<dt>Chiles, J-P, and Delfiner, P., Geostatistics- Modeling Spatial Uncertainty: Wiley,</dt><dd><p>London, 695 p.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seed</strong> (<cite>int</cite>) – integer used for random seed.  If seed is used as a PEST parameter,
then passing the same value for seed will yield the same
conditioned random fields. This allows runs to be recreated
given an ensemble of seeds.</p></li>
<li><p><strong>obs_points</strong> (<cite>str</cite> or <cite>dataframe</cite>) – locations for observation points.  Either filename in pyemu
pilot point file format: [“name”,”x”,”y”,”zone”,”parval1”] or
a dataframe with these columns. Note that parval1 is not used.</p></li>
<li><p><strong>base_values_file</strong> (<cite>str</cite>) – filename containing 2d array with the base parameter values
from which the random field will depart (Z(x)) above.
Values of Z(x) are used for conditioning, not parval1 in the
observation point file.</p></li>
<li><p><strong>factors_file</strong> (<cite>str</cite>) – name of the factors file generated using the locations of the
observation points and the target grid.   If None this file will
be generated and called conditional_factors.dat; but this is a slow
step and should not generally be called for every simulation.</p></li>
<li><p><strong>sg</strong> – flopy StructuredGrid object</p></li>
<li><p><strong>local</strong> (<cite>boolean</cite>) – whether coordinates in obs_points are in local (model) or map coordinates</p></li>
<li><p><strong>num_reals</strong> (<cite>int</cite>) – number of realizations to generate</p></li>
<li><p><strong>mean_value</strong> (<cite>float</cite>) – the mean value of the realizations</p></li>
<li><p><strong>R_factor</strong> (<cite>float</cite>) – a factor to scale the field, sometimes the variation from the
geostruct parameters is larger or smaller than desired.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>a 3-D array of realizations.  Shape</dt><dd><p>is (num_reals, self.dely.shape[0], self.delx.shape[0])</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>log transformation is respected and the returned <cite>reals</cite> array is
in arithmetic space</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.SpecSim2d.grid_is_regular">
<em class="property">static </em><code class="sig-name descname">grid_is_regular</code><span class="sig-paren">(</span><em class="sig-param">delx</em>, <em class="sig-param">dely</em>, <em class="sig-param">tol=0.0001</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.SpecSim2d.grid_is_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>check that a grid is regular using delx and dely vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>delx</strong> – <cite>numpy.ndarray</cite>
a 1-D array of x-dimension cell centers (or leading/trailing edges).  Only the
distance between points is important</p></li>
<li><p><strong>dely</strong> – <cite>numpy.ndarray</cite>
a 1-D array of y-dimension cell centers (or leading/trailing edges).  Only the
distance between points is important</p></li>
<li><p><strong>tol</strong> – <cite>float</cite> (optional)
tolerance to determine grid regularity.  Default is 1.0e-4</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>flag indicating if the grid defined by <cite>delx</cite> and <cite>dely</cite> is regular</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>bool</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.SpecSim2d.grid_par_ensemble_helper">
<code class="sig-name descname">grid_par_ensemble_helper</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">gr_df</em>, <em class="sig-param">num_reals</em>, <em class="sig-param">sigma_range=6</em>, <em class="sig-param">logger=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.SpecSim2d.grid_par_ensemble_helper" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>wrapper around <cite>SpecSim2d.draw()</cite> designed to support <cite>pyemu.PstFromFlopy</cite></dt><dd><p>grid-based parameters</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>gr_df</strong> (<cite>pandas.DataFrame</cite>) – a dataframe listing <cite>parval1</cite>,
<cite>pargp</cite>, <cite>i</cite>, <cite>j</cite> for each grid based parameter</p></li>
<li><p><strong>num_reals</strong> (<cite>int</cite>) – number of realizations to generate</p></li>
<li><p><strong>sigma_range</strong> (<cite>float</cite> (optional)) – number of standard deviations
implied by parameter bounds in control file. Default is 6</p></li>
<li><p><strong>logger</strong> (<cite>pyemu.Logger</cite> (optional)) – a logger instance for logging</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an untransformed parameter ensemble of
realized grid-parameter values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.ParameterEnsemble</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the method processes each unique <cite>pargp</cite> value in <cite>gr_df</cite> and resets the sill of <cite>self.geostruct</cite> by
the maximum bounds-implied variance of each <cite>pargp</cite>.  This method makes repeated calls to
<cite>self.initialize()</cite> to deal with the geostruct changes.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.SpecSim2d.initialize">
<code class="sig-name descname">initialize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.SpecSim2d.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare for spectral simulation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>initialize()</cite> prepares for simulation by undertaking
the fast FFT on the wave number matrix and should be called
if the <cite>SpecSim2d.geostruct</cite> is changed.</p>
<p>This method is called by the constructor.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyemu.utils.geostats.SphVario">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">SphVario</code><span class="sig-paren">(</span><em class="sig-param">contribution</em>, <em class="sig-param">a</em>, <em class="sig-param">anisotropy=1.0</em>, <em class="sig-param">bearing=0.0</em>, <em class="sig-param">name='var1'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.SphVario" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical variogram derived type</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contribution</strong> (<em>float</em>) – sill of the variogram</p></li>
<li><p><strong>a</strong> (<cite>float</cite>) – (practical) range of correlation</p></li>
<li><p><strong>anisotropy</strong> (<cite>float</cite>, optional) – Anisotropy ratio. Default is 1.0</p></li>
<li><p><strong>bearing</strong> – (<cite>float</cite>, optional): angle in degrees East of North corresponding
to anisotropy ellipse. Default is 0.0</p></li>
<li><p><strong>name</strong> – name of the variogram.  Default is “var1”</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pyemu.utils.geostats.Vario2d">
<em class="property">class </em><code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">Vario2d</code><span class="sig-paren">(</span><em class="sig-param">contribution</em>, <em class="sig-param">a</em>, <em class="sig-param">anisotropy=1.0</em>, <em class="sig-param">bearing=0.0</em>, <em class="sig-param">name='var1'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.Vario2d" title="Permalink to this definition">¶</a></dt>
<dd><p>base class for 2-D variograms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>contribution</strong> (<em>float</em>) – sill of the variogram</p></li>
<li><p><strong>a</strong> (<cite>float</cite>) – (practical) range of correlation</p></li>
<li><p><strong>anisotropy</strong> (<cite>float</cite>, optional) – Anisotropy ratio. Default is 1.0</p></li>
<li><p><strong>bearing</strong> – (<cite>float</cite>, optional): angle in degrees East of North corresponding
to anisotropy ellipse. Default is 0.0</p></li>
<li><p><strong>name</strong> (<cite>str</cite>, optinoal) – name of the variogram.  Default is “var1”</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This base class should not be instantiated directly as it does not implement
an h_function() method.</p>
</div>
<dl class="method">
<dt id="pyemu.utils.geostats.Vario2d.bearing_rads">
<em class="property">property </em><code class="sig-name descname">bearing_rads</code><a class="headerlink" href="#pyemu.utils.geostats.Vario2d.bearing_rads" title="Permalink to this definition">¶</a></dt>
<dd><p>get the bearing of the Vario2d in radians</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the Vario2d bearing in radians</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.Vario2d.covariance">
<code class="sig-name descname">covariance</code><span class="sig-paren">(</span><em class="sig-param">pt0</em>, <em class="sig-param">pt1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.Vario2d.covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>get the covarince between two points implied by Vario2d</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pt0</strong> – ([<cite>float</cite>]): first point x and y</p></li>
<li><p><strong>pt1</strong> – ([<cite>float</cite>]): second point x and y</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>covariance between pt0 and pt1</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.Vario2d.covariance_matrix">
<code class="sig-name descname">covariance_matrix</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">names=None</em>, <em class="sig-param">cov=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.Vario2d.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>build a pyemu.Cov instance implied by Vario2d</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> ([<cite>float</cite>]) – x-coordinate locations</p></li>
<li><p><strong>y</strong> ([<cite>float</cite>]) – y-coordinate locations</p></li>
<li><p><strong>names</strong> ([<cite>str</cite>]) – names of locations. If None, cov must not be None</p></li>
<li><p><strong>cov</strong> (<cite>pyemu.Cov</cite>) – an existing Cov instance.  Vario2d contribution is added to cov</p></li>
<li><p><strong>place</strong> (<em>in</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the covariance matrix for <cite>x</cite>, <cite>y</cite> implied by <cite>Vario2d</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pyemu.Cov</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>either <cite>names</cite> or <cite>cov</cite> must not be None.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.Vario2d.covariance_points">
<code class="sig-name descname">covariance_points</code><span class="sig-paren">(</span><em class="sig-param">x0</em>, <em class="sig-param">y0</em>, <em class="sig-param">xother</em>, <em class="sig-param">yother</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.Vario2d.covariance_points" title="Permalink to this definition">¶</a></dt>
<dd><p>get the covariance between base point (x0,y0) and
other points xother,yother implied by <cite>Vario2d</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<cite>float</cite>) – x-coordinate</p></li>
<li><p><strong>y0</strong> (<cite>float</cite>) – y-coordinate</p></li>
<li><p><strong>xother</strong> ([<cite>float</cite>]) – x-coordinates of other points</p></li>
<li><p><strong>yother</strong> ([<cite>float</cite>]) – y-coordinates of other points</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a 1-D array of covariance between point x0,y0 and the
points contained in xother, yother.  len(cov) = len(xother) =
len(yother)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.Vario2d.inv_h">
<code class="sig-name descname">inv_h</code><span class="sig-paren">(</span><em class="sig-param">h</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.Vario2d.inv_h" title="Permalink to this definition">¶</a></dt>
<dd><p>the inverse of the h_function.  Used for plotting</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>h</strong> (<cite>float</cite>) – the value of h_function to invert</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the inverse of h</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.Vario2d.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.Vario2d.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>get a cheap plot of the Vario2d</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> (<cite>dict</cite>) – keyword arguments to use for plotting</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>matplotlib.pyplot.axis</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>optional arguments in kwargs include
“ax” (existing <cite>matplotlib.pyplot.axis</cite>).  Other
kwargs are passed to <cite>matplotlib.pyplot.plot()</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.Vario2d.rotation_coefs">
<em class="property">property </em><code class="sig-name descname">rotation_coefs</code><a class="headerlink" href="#pyemu.utils.geostats.Vario2d.rotation_coefs" title="Permalink to this definition">¶</a></dt>
<dd><p>get the rotation coefficents in radians</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the rotation coefficients implied by <cite>Vario2d.bearing</cite></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>[<cite>float</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyemu.utils.geostats.Vario2d.to_struct_file">
<code class="sig-name descname">to_struct_file</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.Vario2d.to_struct_file" title="Permalink to this definition">¶</a></dt>
<dd><p>write the <cite>Vario2d</cite> to a PEST-style structure file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<cite>str</cite>) – filename to write to.  <cite>f</cite> can also be an open
file handle.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyemu.utils.geostats.fac2real">
<code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">fac2real</code><span class="sig-paren">(</span><em class="sig-param">pp_file=None</em>, <em class="sig-param">factors_file='factors.dat'</em>, <em class="sig-param">out_file='test.ref'</em>, <em class="sig-param">upper_lim=1e+30</em>, <em class="sig-param">lower_lim=-1e+30</em>, <em class="sig-param">fill_value=1e+30</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.fac2real" title="Permalink to this definition">¶</a></dt>
<dd><p>A python replication of the PEST fac2real utility for creating a
structure grid array from previously calculated kriging factors (weights)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pp_file</strong> (<cite>str</cite>) – PEST-type pilot points file</p></li>
<li><p><strong>factors_file</strong> (<cite>str</cite>) – PEST-style factors file</p></li>
<li><p><strong>out_file</strong> (<cite>str</cite>) – filename of array to write.  If None, array is returned, else
value of out_file is returned.  Default is “test.ref”.</p></li>
<li><p><strong>upper_lim</strong> (<cite>float</cite>) – maximum interpolated value in the array.  Values greater than
<cite>upper_lim</cite> are set to fill_value</p></li>
<li><p><strong>lower_lim</strong> (<cite>float</cite>) – minimum interpolated value in the array.  Values less than
<cite>lower_lim</cite> are set to fill_value</p></li>
<li><p><strong>fill_value</strong> (<cite>float</cite>) – the value to assign array nodes that are not interpolated</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>if out_file is None</p>
<p><cite>str</cite>: if out_file it not None</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">fac2real</span><span class="p">(</span><span class="s2">&quot;hkpp.dat&quot;</span><span class="p">,</span><span class="n">out_file</span><span class="o">=</span><span class="s2">&quot;hk_layer_1.ref&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.geostats.gslib_2_dataframe">
<code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">gslib_2_dataframe</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">attr_name=None</em>, <em class="sig-param">x_idx=0</em>, <em class="sig-param">y_idx=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.gslib_2_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>function to read a GSLIB point data file into a pandas.DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<cite>str</cite>) – GSLIB file</p></li>
<li><p><strong>attr_name</strong> (<cite>str</cite>) – the column name in the dataframe for the attribute.
If None, GSLIB file can have only 3 columns.  <cite>attr_name</cite> must be in
the GSLIB file header</p></li>
<li><p><strong>x_idx</strong> (<cite>int</cite>) – the index of the x-coordinate information in the GSLIB file. Default is
0 (first column)</p></li>
<li><p><strong>y_idx</strong> (<cite>int</cite>) – the index of the y-coordinate information in the GSLIB file.
Default is 1 (second column)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dataframe of info from the GSLIB file</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pandas.DataFrame</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>assigns generic point names (“pt0, pt1, etc)</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utiils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">gslib_2_dataframe</span><span class="p">(</span><span class="s2">&quot;prop.gslib&quot;</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s2">&quot;hk&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.geostats.load_sgems_exp_var">
<code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">load_sgems_exp_var</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.load_sgems_exp_var" title="Permalink to this definition">¶</a></dt>
<dd><p>read an SGEM experimental variogram into a sequence of
pandas.DataFrames</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<cite>str</cite>) – an SGEMS experimental variogram XML file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of pandas.DataFrames of x, y, pairs for each
division in the experimental variogram</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[<cite>pandas.DataFrame</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.geostats.read_sgems_variogram_xml">
<code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">read_sgems_variogram_xml</code><span class="sig-paren">(</span><em class="sig-param">xml_file</em>, <em class="sig-param">return_type=&lt;class 'pyemu.utils.geostats.GeoStruct'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.read_sgems_variogram_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>function to read an SGEMS-type variogram XML file into
a <cite>GeoStruct</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xml_file</strong> (<cite>str</cite>) – SGEMS variogram XML file</p></li>
<li><p><strong>return_type</strong> (<cite>object</cite>) – the instance type to return.  Default is <cite>GeoStruct</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>GeoStruct</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>gs</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gs</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">read_sgems_variogram_xml</span><span class="p">(</span><span class="s2">&quot;sgems.xml&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.utils.geostats.read_struct_file">
<code class="sig-prename descclassname">pyemu.utils.geostats.</code><code class="sig-name descname">read_struct_file</code><span class="sig-paren">(</span><em class="sig-param">struct_file</em>, <em class="sig-param">return_type=&lt;class 'pyemu.utils.geostats.GeoStruct'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.utils.geostats.read_struct_file" title="Permalink to this definition">¶</a></dt>
<dd><p>read an existing PEST-type structure file into a GeoStruct instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>struct_file</strong> (<cite>str</cite>) – existing pest-type structure file</p></li>
<li><p><strong>return_type</strong> (<cite>object</cite>) – the instance type to return.  Default is GeoStruct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of <cite>GeoStruct</cite> instances.  If
only one <cite>GeoStruct</cite> is in the file, then a <cite>GeoStruct</cite> is returned</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[<cite>pyemu.GeoStruct</cite>]</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gs</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">geostats</span><span class="o">.</span><span class="n">reads_struct_file</span><span class="p">(</span><span class="s2">&quot;struct.dat&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-pyemu.plot.plot_utils"></span><p>Plotting functions for various PEST(++) and pyemu operations</p>
<dl class="function">
<dt id="pyemu.plot.plot_utils.ensemble_change_summary">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">ensemble_change_summary</code><span class="sig-paren">(</span><em class="sig-param">ensemble1</em>, <em class="sig-param">ensemble2</em>, <em class="sig-param">pst</em>, <em class="sig-param">bins=10</em>, <em class="sig-param">facecolor='0.5'</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.ensemble_change_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to plot first and second moment change histograms between two
ensembles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble1</strong> (<em>varies</em>) – filename or <cite>pandas.DataFrame</cite> or <cite>pyemu.Ensemble</cite></p></li>
<li><p><strong>ensemble2</strong> (<em>varies</em>) – filename or <cite>pandas.DataFrame</cite> or <cite>pyemu.Ensemble</cite></p></li>
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – control file</p></li>
<li><p><strong>facecolor</strong> (<cite>str</cite>) – the histogram facecolor.</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>) – the name of the multi-pdf to create. If None, return figs without saving.  Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of figures.  Returns None is
<cite>filename</cite> is not None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[<cite>matplotlib.Figure</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.ensemble_helper">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">ensemble_helper</code><span class="sig-paren">(</span><em class="sig-param">ensemble</em>, <em class="sig-param">bins=10</em>, <em class="sig-param">facecolor='0.5'</em>, <em class="sig-param">plot_cols=None</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">func_dict=None</em>, <em class="sig-param">sync_bins=True</em>, <em class="sig-param">deter_vals=None</em>, <em class="sig-param">std_window=None</em>, <em class="sig-param">deter_range=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.ensemble_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to plot ensemble histograms</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> – varies
the ensemble argument can be a pandas.DataFrame or derived type or a str, which
is treated as a filename.  Optionally, ensemble can be a list of these types or
a dict, in which case, the keys are treated as facecolor str (e.g., ‘b’, ‘y’, etc).</p></li>
<li><p><strong>facecolor</strong> – str
the histogram facecolor.  Only applies if ensemble is a single thing</p></li>
<li><p><strong>plot_cols</strong> – enumerable
a collection of columns (in form of a list of parameters, or a dict with keys for
parsing plot axes and values of parameters) from the ensemble(s) to plot.  If None,
(the union of) all cols are plotted. Default is None</p></li>
<li><p><strong>filename</strong> – str
the name of the pdf to create.  If None, return figs without saving.  Default is None.</p></li>
<li><p><strong>func_dict</strong> – dict
a dictionary of unary functions (e.g., <cite>np.log10</cite> to apply to columns.  Key is
column name.  Default is None</p></li>
<li><p><strong>sync_bins</strong> – bool
flag to use the same bin edges for all ensembles. Only applies if more than
one ensemble is being plotted.  Default is True</p></li>
<li><p><strong>deter_vals</strong> – dict
dict of deterministic values to plot as a vertical line. key is ensemble columnn name</p></li>
<li><p><strong>std_window</strong> – float
the number of standard deviations around the mean to mark as vertical lines.  If None,
nothing happens.  Default is None</p></li>
<li><p><strong>deter_range</strong> – bool
flag to set xlims to deterministic value +/- std window.  If True, std_window must not be None.
Default is False</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_binary</span><span class="p">(</span><span class="n">pst</span><span class="o">=</span><span class="n">pst</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;prior.jcb&quot;</span><span class="p">)</span>
<span class="n">post</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ParameterEnsemble</span><span class="o">.</span><span class="n">from_binary</span><span class="p">(</span><span class="n">pst</span><span class="o">=</span><span class="n">pst</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;my.3.par.jcb&quot;</span><span class="p">)</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">plot_utils</span><span class="o">.</span><span class="n">ensemble_helper</span><span class="p">(</span><span class="n">ensemble</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;0.5&quot;</span><span class="p">:</span><span class="n">prior</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span><span class="n">post</span><span class="p">},</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;ensemble.pdf&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.ensemble_res_1to1">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">ensemble_res_1to1</code><span class="sig-paren">(</span><em class="sig-param">ensemble</em>, <em class="sig-param">pst</em>, <em class="sig-param">facecolor='0.5'</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">skip_groups=[]</em>, <em class="sig-param">base_ensemble=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.ensemble_res_1to1" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to plot ensemble 1-to-1 plots sbowing the simulated range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> (<em>varies</em>) – the ensemble argument can be a pandas.DataFrame or derived type or a str, which
is treated as a fileanme.  Optionally, ensemble can be a list of these types or
a dict, in which case, the keys are treated as facecolor str (e.g., ‘b’, ‘y’, etc).</p></li>
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>facecolor</strong> (<cite>str</cite>) – the histogram facecolor.  Only applies if <cite>ensemble</cite> is a single thing</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>) – the name of the pdf to create. If None, return figs
without saving.  Default is None.</p></li>
<li><p><strong>base_ensemble</strong> (<cite>varies</cite>) – an optional ensemble argument for the observations + noise ensemble.
This will be plotted as a transparent red bar on the 1to1 plot.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.gaussian_distribution">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">gaussian_distribution</code><span class="sig-paren">(</span><em class="sig-param">mean</em>, <em class="sig-param">stdev</em>, <em class="sig-param">num_pts=50</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.gaussian_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>get an x and y numpy.ndarray that spans the +/- 4
standard deviation range of a gaussian distribution with
a given mean and standard deviation. useful for plotting</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mean</strong> (<cite>float</cite>) – the mean of the distribution</p></li>
<li><p><strong>stdev</strong> (<cite>float</cite>) – the standard deviation of the distribution</p></li>
<li><p><strong>num_pts</strong> (<cite>int</cite>) – the number of points in the returned ndarrays.
Default is 50</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>numpy.ndarray</strong>: the x-values of the distribution</p></li>
<li><p><strong>numpy.ndarray</strong>: the y-values of the distribution</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple containing</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.phi_progress">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">phi_progress</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.phi_progress" title="Permalink to this definition">¶</a></dt>
<dd><p>make plot of phi vs number of model runs - requires
available  “.iobj” file generated by a PESTPP-GLM run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>logger</strong> (<cite>pyemu.Logger</cite>) – if None, a generic one is created.  Default is None</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>) – PDF filename to save figures to.  If None, figures
are returned.  Default is None</p></li>
<li><p><strong>kwargs</strong> (<cite>dict</cite>) – optional keyword args to pass to plotting function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the axis the plot was made on</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>matplotlib.axis</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pyemu</span>
<span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">plot_utils</span><span class="o">.</span><span class="n">phi_progress</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.plot_id_bar">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">plot_id_bar</code><span class="sig-paren">(</span><em class="sig-param">id_df</em>, <em class="sig-param">nsv=None</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.plot_id_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a stacked bar chart of identifiability based on
a the <cite>pyemu.ErrVar.get_identifiability()</cite> dataframe</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id_df</strong> (<cite>pandas.DataFrame</cite>) – dataframe of identifiability</p></li>
<li><p><strong>nsv</strong> (<cite>int</cite>) – number of singular values to consider</p></li>
<li><p><strong>logger</strong> (<cite>pyemu.Logger</cite>, optonal) – a logger.  If None, a generic
one is created</p></li>
<li><p><strong>kwargs</strong> (<cite>dict</cite>) – a dict of keyword arguments to pass to the
plotting function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the axis with the plot</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>matplotlib.Axis</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyemu</span>
<span class="n">pest_obj</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="n">pest_control_file</span><span class="p">)</span>
<span class="n">ev</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">ErrVar</span><span class="p">(</span><span class="n">jco</span><span class="o">=</span><span class="s1">&#39;freyberg_jac.jcb&#39;</span><span class="p">))</span>
<span class="n">id_df</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">get_identifiability_dataframe</span><span class="p">(</span><span class="n">singular_value</span><span class="o">=</span><span class="mi">48</span><span class="p">)</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">plot_utils</span><span class="o">.</span><span class="n">plot_id_bar</span><span class="p">(</span><span class="n">id_df</span><span class="p">,</span> <span class="n">nsv</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.plot_jac_test">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">plot_jac_test</code><span class="sig-paren">(</span><em class="sig-param">csvin</em>, <em class="sig-param">csvout</em>, <em class="sig-param">targetobs=None</em>, <em class="sig-param">filetype=None</em>, <em class="sig-param">maxoutputpages=1</em>, <em class="sig-param">outputdirectory=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.plot_jac_test" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to plot results of the Jacobian test performed using the pest++
program pestpp-swp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>csvin</strong> (<cite>str</cite>) – name of csv file used as input to sweep, typically developed with
static method pyemu.helpers.build_jac_test_csv()</p></li>
<li><p><strong>csvout</strong> (<cite>str</cite>) – name of csv file with output generated by sweep, both input
and output files can be specified in the pest++ control file
with pyemu using: pest_object.pestpp_options[“sweep_parameter_csv_file”] = jactest_in_file.csv
pest_object.pestpp_options[“sweep_output_csv_file”] = jactest_out_file.csv</p></li>
<li><p><strong>targetobs</strong> ([<cite>str</cite>]) – list of observation file names to plot, each parameter used for jactest can
have up to 32 observations plotted per page, throws a warning if more tha
10 pages of output are requested per parameter. If none, all observations in
the output csv file are used.</p></li>
<li><p><strong>filetype</strong> (<cite>str</cite>) – file type to store output, if None, plt.show() is called.</p></li>
<li><p><strong>maxoutputpages</strong> (<cite>int</cite>) – maximum number of pages of output per parameter.  Each page can
hold up to 32 observation derivatives.  If value &gt; 10, set it to
10 and throw a warning.  If observations in targetobs &gt; 32*maxoutputpages,
then a random set is selected from the targetobs list (or all observations
in the csv file if targetobs=None).</p></li>
<li><p><strong>outputdirectory</strong> (<cite>str</cite>) – directory to store results, if None, current working directory is used.
If string is passed, it is joined to the current working directory and
created if needed. If os.path is passed, it is used directly.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Used in conjunction with pyemu.helpers.build_jac_test_csv() and sweep to perform
a Jacobian Test and then view the results. Can generate a lot of plots so easiest
to put into a separate directory and view the files.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.plot_summary_distributions">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">plot_summary_distributions</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">label_post=False</em>, <em class="sig-param">label_prior=False</em>, <em class="sig-param">subplots=False</em>, <em class="sig-param">figsize=(11</em>, <em class="sig-param">8.5)</em>, <em class="sig-param">pt_color='b'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.plot_summary_distributions" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to plot gaussian distrbutions from prior and posterior
means and standard deviations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<cite>pandas.DataFrame</cite>) – a dataframe and csv file.  Must have columns named:
‘prior_mean’,’prior_stdev’,’post_mean’,’post_stdev’.  If loaded
from a csv file, column 0 is assumed to tbe the index</p></li>
<li><p><strong>ax</strong> (<cite>atplotlib.pyplot.axis</cite>) – If None, and not subplots, then one is created
and all distributions are plotted on a single plot</p></li>
<li><p><strong>label_post</strong> (<cite>bool</cite>) – flag to add text labels to the peak of the posterior</p></li>
<li><p><strong>label_prior</strong> (<cite>bool</cite>) – flag to add text labels to the peak of the prior</p></li>
<li><p><strong>subplots</strong> (<cite>bool</cite>) – flag to use subplots.  If True, then 6 axes per page
are used and a single prior and posterior is plotted on each</p></li>
<li><p><strong>figsize</strong> (<cite>tuple</cite>) – matplotlib figure size</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>[`matplotlib.figure`]</strong>: list of figures</p></li>
<li><p><strong>[`matplotlib.axis`]</strong>: list of axes</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple containing</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is useful for demystifying FOSM results</p>
<p>if subplots is False, a single axis is returned</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pyemu</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">plot_utils</span><span class="o">.</span><span class="n">plot_summary_distributions</span><span class="p">(</span><span class="s2">&quot;pest.par.usum.csv&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.pst_helper">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">pst_helper</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">kind=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.pst_helper" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>pyemu.Pst</cite> plot helper - takes the
handoff from <cite>pyemu.Pst.plot()</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kind</strong> (<cite>str</cite>) – the kind of plot to make</p></li>
<li><p><strong>**kargs</strong> (<cite>dict</cite>) – keyword arguments to pass to the
plotting function and ultimately to <cite>matplotlib</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>usually a combination of <cite>matplotlib.figure</cite> (s) and/or
<cite>matplotlib.axis</cite> (s)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>varies</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.pst_prior">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">pst_prior</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.pst_prior" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to plot prior parameter histograms implied by
parameter bounds. Saves a multipage pdf named &lt;case&gt;.prior.pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – control file</p></li>
<li><p><strong>logger</strong> (<cite>pyemu.Logger</cite>) – a logger.  If None, a generic one is created.</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>) – PDF filename to save plots to.
If None, return figs without saving.  Default is None.</p></li>
<li><p><strong>kwargs</strong> (<cite>dict</cite>) – additional plotting options. Accepts ‘grouper’ as
dict to group parameters on to a single axis (use
parameter groups if not passed),’unqiue_only’ to only show unique
mean-stdev combinations within a given group.  Any additional args
are passed to <cite>matplotlib</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of figures created.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[<cite>matplotlib.Figure</cite>]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.res_1to1">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">res_1to1</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">plot_hexbin=False</em>, <em class="sig-param">histogram=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.res_1to1" title="Permalink to this definition">¶</a></dt>
<dd><p>make 1-to-1 plots and also observed vs residual by observation group</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance</p></li>
<li><p><strong>logger</strong> (<cite>pyemu.Logger</cite>) – if None, a generic one is created.  Default is None</p></li>
<li><p><strong>filename</strong> (<cite>str</cite>) – PDF filename to save figures to.  If None, figures
are returned.  Default is None</p></li>
<li><p><strong>hexbin</strong> (<cite>bool</cite>) – flag to use the hexbinning for large numbers of residuals.
Default is False</p></li>
<li><p><strong>histogram</strong> (<cite>bool</cite>) – flag to plot residual histograms instead of obs vs residual.
Default is False (use <cite>matplotlib.pyplot.scatter</cite> )</p></li>
<li><p><strong>kwargs</strong> (<cite>dict</cite>) – optional keyword args to pass to plotting function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the axis the plot was made on</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>matplotlib.axis</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pyemu</span>
<span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">plot_utils</span><span class="o">.</span><span class="n">phi_progress</span><span class="p">(</span><span class="n">pst</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyemu.plot.plot_utils.res_phi_pie">
<code class="sig-prename descclassname">pyemu.plot.plot_utils.</code><code class="sig-name descname">res_phi_pie</code><span class="sig-paren">(</span><em class="sig-param">pst</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyemu.plot.plot_utils.res_phi_pie" title="Permalink to this definition">¶</a></dt>
<dd><p>plot current phi components as a pie chart.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pst</strong> (<cite>pyemu.Pst</cite>) – a control file instance with the residual datafrane
instance available.</p></li>
<li><p><strong>logger</strong> (<cite>pyemu.Logger</cite>) – a logger.  If None, a generic one is created</p></li>
<li><p><strong>kwargs</strong> (<cite>dict</cite>) – a dict of plotting options. Accepts ‘include_zero’
as a flag to include phi groups with only zero-weight obs (not
sure why anyone would do this, but whatevs). Any additional
args are passed to <cite>matplotlib</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the axis with the plot.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>matplotlib.Axis</cite></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyemu</span>
<span class="n">pst</span> <span class="o">=</span> <span class="n">pyemu</span><span class="o">.</span><span class="n">Pst</span><span class="p">(</span><span class="s2">&quot;my.pst&quot;</span><span class="p">)</span>
<span class="n">pyemu</span><span class="o">.</span><span class="n">plot_utils</span><span class="o">.</span><span class="n">res_phi_pie</span><span class="p">(</span><span class="n">pst</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="_autosummary/pyemu.Pst.html" class="btn btn-neutral float-right" title="pyemu.Pst" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, pyEMU development team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>